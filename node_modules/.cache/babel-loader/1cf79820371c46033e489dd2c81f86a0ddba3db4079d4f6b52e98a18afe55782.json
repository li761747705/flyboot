{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.set.difference.v2.js\";\nimport \"core-js/modules/es.set.intersection.v2.js\";\nimport \"core-js/modules/es.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/es.set.is-subset-of.v2.js\";\nimport \"core-js/modules/es.set.is-superset-of.v2.js\";\nimport \"core-js/modules/es.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/es.set.union.v2.js\";\n/*!\n  * message-compiler v12.0.0-alpha.2\n  * (c) 2016-present kazuya kawaguchi and contributors\n  * Released under the MIT License.\n  */\nimport { format, isString, join, assign } from '@intlify/shared';\nconst LOCATION_STUB = {\n  start: {\n    line: 1,\n    column: 1,\n    offset: 0\n  },\n  end: {\n    line: 1,\n    column: 1,\n    offset: 0\n  }\n};\nfunction createPosition(line, column, offset) {\n  return {\n    line,\n    column,\n    offset\n  };\n}\nfunction createLocation(start, end, source) {\n  const loc = {\n    start,\n    end\n  };\n  if (source != null) {\n    loc.source = source;\n  }\n  return loc;\n}\nconst CompileErrorCodes = {\n  // tokenizer error codes\n  EXPECTED_TOKEN: 1,\n  INVALID_TOKEN_IN_PLACEHOLDER: 2,\n  UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER: 3,\n  UNKNOWN_ESCAPE_SEQUENCE: 4,\n  INVALID_UNICODE_ESCAPE_SEQUENCE: 5,\n  UNBALANCED_CLOSING_BRACE: 6,\n  UNTERMINATED_CLOSING_BRACE: 7,\n  EMPTY_PLACEHOLDER: 8,\n  NOT_ALLOW_NEST_PLACEHOLDER: 9,\n  INVALID_LINKED_FORMAT: 10,\n  // parser error codes\n  MUST_HAVE_MESSAGES_IN_PLURAL: 11,\n  UNEXPECTED_EMPTY_LINKED_MODIFIER: 12,\n  UNEXPECTED_EMPTY_LINKED_KEY: 13,\n  UNEXPECTED_LEXICAL_ANALYSIS: 14,\n  // generator error codes\n  UNHANDLED_CODEGEN_NODE_TYPE: 15,\n  // minifier error codes\n  UNHANDLED_MINIFIER_NODE_TYPE: 16\n};\n// Special value for higher-order compilers to pick up the last code\n// to avoid collision of error codes.\n// This should always be kept as the last item.\nconst COMPILE_ERROR_CODES_EXTEND_POINT = 17;\n/** @internal */\nconst errorMessages = {\n  // tokenizer error messages\n  [CompileErrorCodes.EXPECTED_TOKEN]: `Expected token: '{0}'`,\n  [CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER]: `Invalid token in placeholder: '{0}'`,\n  [CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER]: `Unterminated single quote in placeholder`,\n  [CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE]: `Unknown escape sequence: \\\\{0}`,\n  [CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE]: `Invalid unicode escape sequence: {0}`,\n  [CompileErrorCodes.UNBALANCED_CLOSING_BRACE]: `Unbalanced closing brace`,\n  [CompileErrorCodes.UNTERMINATED_CLOSING_BRACE]: `Unterminated closing brace`,\n  [CompileErrorCodes.EMPTY_PLACEHOLDER]: `Empty placeholder`,\n  [CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER]: `Not allowed nest placeholder`,\n  [CompileErrorCodes.INVALID_LINKED_FORMAT]: `Invalid linked format`,\n  // parser error messages\n  [CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL]: `Plural must have messages`,\n  [CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER]: `Unexpected empty linked modifier`,\n  [CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY]: `Unexpected empty linked key`,\n  [CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS]: `Unexpected lexical analysis in token: '{0}'`,\n  // generator error messages\n  [CompileErrorCodes.UNHANDLED_CODEGEN_NODE_TYPE]: `unhandled codegen node type: '{0}'`,\n  // minimizer error messages\n  [CompileErrorCodes.UNHANDLED_MINIFIER_NODE_TYPE]: `unhandled mimifier node type: '{0}'`\n};\nfunction createCompileError(code, loc, options = {}) {\n  const {\n    domain,\n    messages,\n    args\n  } = options;\n  const msg = process.env.NODE_ENV !== 'production' ? format((messages || errorMessages)[code] || '', ...(args || [])) : code;\n  const error = new SyntaxError(String(msg));\n  error.code = code;\n  if (loc) {\n    error.location = loc;\n  }\n  error.domain = domain;\n  return error;\n}\n/** @internal */\nfunction defaultOnError(error) {\n  throw error;\n}\n\n// eslint-disable-next-line @typescript-eslint/triple-slash-reference\n/// <reference types=\"source-map-js\" />\nconst ERROR_DOMAIN$3 = 'parser';\nfunction createCodeGenerator(ast, options) {\n  const {\n    sourceMap,\n    filename,\n    breakLineCode,\n    needIndent: _needIndent\n  } = options;\n  const location = options.location !== false;\n  const _context = {\n    filename,\n    code: '',\n    column: 1,\n    line: 1,\n    offset: 0,\n    map: undefined,\n    breakLineCode,\n    needIndent: _needIndent,\n    indentLevel: 0\n  };\n  if (location && ast.loc) {\n    _context.source = ast.loc.source;\n  }\n  const context = () => _context;\n  function push(code, node) {\n    _context.code += code;\n  }\n  function _newline(n, withBreakLine = true) {\n    const _breakLineCode = withBreakLine ? breakLineCode : '';\n    push(_needIndent ? _breakLineCode + `  `.repeat(n) : _breakLineCode);\n  }\n  function indent(withNewLine = true) {\n    const level = ++_context.indentLevel;\n    withNewLine && _newline(level);\n  }\n  function deindent(withNewLine = true) {\n    const level = --_context.indentLevel;\n    withNewLine && _newline(level);\n  }\n  function newline() {\n    _newline(_context.indentLevel);\n  }\n  const helper = key => `_${key}`;\n  const needIndent = () => _context.needIndent;\n  return {\n    context,\n    push,\n    indent,\n    deindent,\n    newline,\n    helper,\n    needIndent\n  };\n}\nfunction generateLinkedNode(generator, node) {\n  const {\n    helper\n  } = generator;\n  generator.push(`${helper(\"linked\" /* HelperNameMap.LINKED */)}(`);\n  generateNode(generator, node.key);\n  if (node.modifier) {\n    generator.push(`, `);\n    generateNode(generator, node.modifier);\n    generator.push(`, _type`);\n  } else {\n    generator.push(`, undefined, _type`);\n  }\n  generator.push(`)`);\n}\nfunction generateMessageNode(generator, node) {\n  const {\n    helper,\n    needIndent\n  } = generator;\n  generator.push(`${helper(\"normalize\" /* HelperNameMap.NORMALIZE */)}([`);\n  generator.indent(needIndent());\n  const length = node.items.length;\n  for (let i = 0; i < length; i++) {\n    generateNode(generator, node.items[i]);\n    if (i === length - 1) {\n      break;\n    }\n    generator.push(', ');\n  }\n  generator.deindent(needIndent());\n  generator.push('])');\n}\nfunction generatePluralNode(generator, node) {\n  const {\n    helper,\n    needIndent\n  } = generator;\n  if (node.cases.length > 1) {\n    generator.push(`${helper(\"plural\" /* HelperNameMap.PLURAL */)}([`);\n    generator.indent(needIndent());\n    const length = node.cases.length;\n    for (let i = 0; i < length; i++) {\n      generateNode(generator, node.cases[i]);\n      if (i === length - 1) {\n        break;\n      }\n      generator.push(', ');\n    }\n    generator.deindent(needIndent());\n    generator.push(`])`);\n  }\n}\nfunction generateResource(generator, node) {\n  if (node.body) {\n    generateNode(generator, node.body);\n  } else {\n    generator.push('null');\n  }\n}\nfunction generateNode(generator, node) {\n  const {\n    helper\n  } = generator;\n  switch (node.type) {\n    case 0 /* NodeTypes.Resource */:\n      generateResource(generator, node);\n      break;\n    case 1 /* NodeTypes.Plural */:\n      generatePluralNode(generator, node);\n      break;\n    case 2 /* NodeTypes.Message */:\n      generateMessageNode(generator, node);\n      break;\n    case 6 /* NodeTypes.Linked */:\n      generateLinkedNode(generator, node);\n      break;\n    case 8 /* NodeTypes.LinkedModifier */:\n      generator.push(JSON.stringify(node.value), node);\n      break;\n    case 7 /* NodeTypes.LinkedKey */:\n      generator.push(JSON.stringify(node.value), node);\n      break;\n    case 5 /* NodeTypes.List */:\n      generator.push(`${helper(\"interpolate\" /* HelperNameMap.INTERPOLATE */)}(${helper(\"list\" /* HelperNameMap.LIST */)}(${node.index}))`, node);\n      break;\n    case 4 /* NodeTypes.Named */:\n      generator.push(`${helper(\"interpolate\" /* HelperNameMap.INTERPOLATE */)}(${helper(\"named\" /* HelperNameMap.NAMED */)}(${JSON.stringify(node.key)}))`, node);\n      break;\n    case 9 /* NodeTypes.Literal */:\n      generator.push(JSON.stringify(node.value), node);\n      break;\n    case 3 /* NodeTypes.Text */:\n      generator.push(JSON.stringify(node.value), node);\n      break;\n    default:\n      if (process.env.NODE_ENV !== 'production') {\n        throw createCompileError(CompileErrorCodes.UNHANDLED_CODEGEN_NODE_TYPE, null, {\n          domain: ERROR_DOMAIN$3,\n          args: [node.type]\n        });\n      }\n  }\n}\n// generate code from AST\nconst generate = (ast, options = {}) => {\n  const mode = isString(options.mode) ? options.mode : 'normal';\n  const filename = isString(options.filename) ? options.filename : 'message.intl';\n  const sourceMap = !!options.sourceMap;\n  // prettier-ignore\n  const breakLineCode = options.breakLineCode != null ? options.breakLineCode : mode === 'arrow' ? ';' : '\\n';\n  const needIndent = options.needIndent ? options.needIndent : mode !== 'arrow';\n  const helpers = ast.helpers || [];\n  const generator = createCodeGenerator(ast, {\n    mode,\n    filename,\n    sourceMap,\n    breakLineCode,\n    needIndent\n  });\n  generator.push(mode === 'normal' ? `function __msg__ (ctx) {` : `(ctx) => {`);\n  generator.indent(needIndent);\n  if (helpers.length > 0) {\n    generator.push(`const { ${join(helpers.map(s => `${s}: _${s}`), ', ')} } = ctx`);\n    generator.newline();\n  }\n  generator.push(`return `);\n  generateNode(generator, ast);\n  generator.deindent(needIndent);\n  generator.push(`}`);\n  delete ast.helpers;\n  const {\n    code,\n    map\n  } = generator.context();\n  return {\n    ast,\n    code,\n    map: map ? map.toJSON() : undefined // eslint-disable-line @typescript-eslint/no-explicit-any\n  };\n};\nconst ERROR_DOMAIN$2 = 'minifier';\n/* eslint-disable @typescript-eslint/no-explicit-any */\nfunction mangle(node) {\n  node.t = node.type;\n  switch (node.type) {\n    case 0 /* NodeTypes.Resource */:\n      {\n        const resource = node;\n        mangle(resource.body);\n        resource.b = resource.body;\n        delete resource.body;\n        break;\n      }\n    case 1 /* NodeTypes.Plural */:\n      {\n        const plural = node;\n        const cases = plural.cases;\n        for (let i = 0; i < cases.length; i++) {\n          mangle(cases[i]);\n        }\n        plural.c = cases;\n        delete plural.cases;\n        break;\n      }\n    case 2 /* NodeTypes.Message */:\n      {\n        const message = node;\n        const items = message.items;\n        for (let i = 0; i < items.length; i++) {\n          mangle(items[i]);\n        }\n        message.i = items;\n        delete message.items;\n        if (message.static) {\n          message.s = message.static;\n          delete message.static;\n        }\n        break;\n      }\n    case 3 /* NodeTypes.Text */:\n    case 9 /* NodeTypes.Literal */:\n    case 8 /* NodeTypes.LinkedModifier */:\n    case 7 /* NodeTypes.LinkedKey */:\n      {\n        const valueNode = node;\n        if (valueNode.value) {\n          valueNode.v = valueNode.value;\n          delete valueNode.value;\n        }\n        break;\n      }\n    case 6 /* NodeTypes.Linked */:\n      {\n        const linked = node;\n        mangle(linked.key);\n        linked.k = linked.key;\n        delete linked.key;\n        if (linked.modifier) {\n          mangle(linked.modifier);\n          linked.m = linked.modifier;\n          delete linked.modifier;\n        }\n        break;\n      }\n    case 5 /* NodeTypes.List */:\n      {\n        const list = node;\n        list.i = list.index;\n        delete list.index;\n        break;\n      }\n    case 4 /* NodeTypes.Named */:\n      {\n        const named = node;\n        named.k = named.key;\n        delete named.key;\n        break;\n      }\n    default:\n      if (process.env.NODE_ENV !== 'production') {\n        throw createCompileError(CompileErrorCodes.UNHANDLED_MINIFIER_NODE_TYPE, null, {\n          domain: ERROR_DOMAIN$2,\n          args: [node.type]\n        });\n      }\n  }\n  delete node.type;\n}\n/* eslint-enable @typescript-eslint/no-explicit-any */\n\nfunction optimize(ast) {\n  const body = ast.body;\n  if (body.type === 2 /* NodeTypes.Message */) {\n    optimizeMessageNode(body);\n  } else {\n    body.cases.forEach(c => optimizeMessageNode(c));\n  }\n  return ast;\n}\nfunction optimizeMessageNode(message) {\n  if (message.items.length === 1) {\n    const item = message.items[0];\n    if (item.type === 3 /* NodeTypes.Text */ || item.type === 9 /* NodeTypes.Literal */) {\n      message.static = item.value;\n      delete item.value; // optimization for size\n    }\n  } else {\n    const values = [];\n    for (let i = 0; i < message.items.length; i++) {\n      const item = message.items[i];\n      if (!(item.type === 3 /* NodeTypes.Text */ || item.type === 9 /* NodeTypes.Literal */)) {\n        break;\n      }\n      if (item.value == null) {\n        break;\n      }\n      values.push(item.value);\n    }\n    if (values.length === message.items.length) {\n      message.static = join(values);\n      for (let i = 0; i < message.items.length; i++) {\n        const item = message.items[i];\n        if (item.type === 3 /* NodeTypes.Text */ || item.type === 9 /* NodeTypes.Literal */) {\n          delete item.value; // optimization for size\n        }\n      }\n    }\n  }\n}\nconst CHAR_SP = ' ';\nconst CHAR_CR = '\\r';\nconst CHAR_LF = '\\n';\nconst CHAR_LS = String.fromCharCode(0x2028);\nconst CHAR_PS = String.fromCharCode(0x2029);\nfunction createScanner(str) {\n  const _buf = str;\n  let _index = 0;\n  let _line = 1;\n  let _column = 1;\n  let _peekOffset = 0;\n  const isCRLF = index => _buf[index] === CHAR_CR && _buf[index + 1] === CHAR_LF;\n  const isLF = index => _buf[index] === CHAR_LF;\n  const isPS = index => _buf[index] === CHAR_PS;\n  const isLS = index => _buf[index] === CHAR_LS;\n  const isLineEnd = index => isCRLF(index) || isLF(index) || isPS(index) || isLS(index);\n  const index = () => _index;\n  const line = () => _line;\n  const column = () => _column;\n  const peekOffset = () => _peekOffset;\n  const charAt = offset => isCRLF(offset) || isPS(offset) || isLS(offset) ? CHAR_LF : _buf[offset];\n  const currentChar = () => charAt(_index);\n  const currentPeek = () => charAt(_index + _peekOffset);\n  function next() {\n    _peekOffset = 0;\n    if (isLineEnd(_index)) {\n      _line++;\n      _column = 0;\n    }\n    if (isCRLF(_index)) {\n      _index++;\n    }\n    _index++;\n    _column++;\n    return _buf[_index];\n  }\n  function peek() {\n    if (isCRLF(_index + _peekOffset)) {\n      _peekOffset++;\n    }\n    _peekOffset++;\n    return _buf[_index + _peekOffset];\n  }\n  function reset() {\n    _index = 0;\n    _line = 1;\n    _column = 1;\n    _peekOffset = 0;\n  }\n  function resetPeek(offset = 0) {\n    _peekOffset = offset;\n  }\n  function skipToPeek() {\n    const target = _index + _peekOffset;\n    while (target !== _index) {\n      next();\n    }\n    _peekOffset = 0;\n  }\n  return {\n    index,\n    line,\n    column,\n    peekOffset,\n    charAt,\n    currentChar,\n    currentPeek,\n    next,\n    peek,\n    reset,\n    resetPeek,\n    skipToPeek\n  };\n}\nconst EOF = undefined;\nconst DOT = '.';\nconst LITERAL_DELIMITER = \"'\";\nconst ERROR_DOMAIN$1 = 'tokenizer';\nfunction createTokenizer(source, options = {}) {\n  const location = options.location !== false;\n  const _scnr = createScanner(source);\n  const currentOffset = () => _scnr.index();\n  const currentPosition = () => createPosition(_scnr.line(), _scnr.column(), _scnr.index());\n  const _initLoc = currentPosition();\n  const _initOffset = currentOffset();\n  const _context = {\n    currentType: 13 /* TokenTypes.EOF */,\n    offset: _initOffset,\n    startLoc: _initLoc,\n    endLoc: _initLoc,\n    lastType: 13 /* TokenTypes.EOF */,\n    lastOffset: _initOffset,\n    lastStartLoc: _initLoc,\n    lastEndLoc: _initLoc,\n    braceNest: 0,\n    inLinked: false,\n    text: ''\n  };\n  const context = () => _context;\n  const {\n    onError\n  } = options;\n  function emitError(code, pos, offset, ...args) {\n    const ctx = context();\n    pos.column += offset;\n    pos.offset += offset;\n    if (onError) {\n      const loc = location ? createLocation(ctx.startLoc, pos) : null;\n      const err = createCompileError(code, loc, {\n        domain: ERROR_DOMAIN$1,\n        args\n      });\n      onError(err);\n    }\n  }\n  function getToken(context, type, value) {\n    context.endLoc = currentPosition();\n    context.currentType = type;\n    const token = {\n      type\n    };\n    if (location) {\n      token.loc = createLocation(context.startLoc, context.endLoc);\n    }\n    if (value != null) {\n      token.value = value;\n    }\n    return token;\n  }\n  const getEndToken = context => getToken(context, 13 /* TokenTypes.EOF */);\n  function eat(scnr, ch) {\n    if (scnr.currentChar() === ch) {\n      scnr.next();\n      return ch;\n    } else {\n      emitError(CompileErrorCodes.EXPECTED_TOKEN, currentPosition(), 0, ch);\n      return '';\n    }\n  }\n  function peekSpaces(scnr) {\n    let buf = '';\n    while (scnr.currentPeek() === CHAR_SP || scnr.currentPeek() === CHAR_LF) {\n      buf += scnr.currentPeek();\n      scnr.peek();\n    }\n    return buf;\n  }\n  function skipSpaces(scnr) {\n    const buf = peekSpaces(scnr);\n    scnr.skipToPeek();\n    return buf;\n  }\n  function isIdentifierStart(ch) {\n    if (ch === EOF) {\n      return false;\n    }\n    const cc = ch.charCodeAt(0);\n    return cc >= 97 && cc <= 122 ||\n    // a-z\n    cc >= 65 && cc <= 90 ||\n    // A-Z\n    cc === 95 // _\n    ;\n  }\n  function isNumberStart(ch) {\n    if (ch === EOF) {\n      return false;\n    }\n    const cc = ch.charCodeAt(0);\n    return cc >= 48 && cc <= 57; // 0-9\n  }\n  function isNamedIdentifierStart(scnr, context) {\n    const {\n      currentType\n    } = context;\n    if (currentType !== 2 /* TokenTypes.BraceLeft */) {\n      return false;\n    }\n    peekSpaces(scnr);\n    const ret = isIdentifierStart(scnr.currentPeek());\n    scnr.resetPeek();\n    return ret;\n  }\n  function isListIdentifierStart(scnr, context) {\n    const {\n      currentType\n    } = context;\n    if (currentType !== 2 /* TokenTypes.BraceLeft */) {\n      return false;\n    }\n    peekSpaces(scnr);\n    const ch = scnr.currentPeek() === '-' ? scnr.peek() : scnr.currentPeek();\n    const ret = isNumberStart(ch);\n    scnr.resetPeek();\n    return ret;\n  }\n  function isLiteralStart(scnr, context) {\n    const {\n      currentType\n    } = context;\n    if (currentType !== 2 /* TokenTypes.BraceLeft */) {\n      return false;\n    }\n    peekSpaces(scnr);\n    const ret = scnr.currentPeek() === LITERAL_DELIMITER;\n    scnr.resetPeek();\n    return ret;\n  }\n  function isLinkedDotStart(scnr, context) {\n    const {\n      currentType\n    } = context;\n    if (currentType !== 7 /* TokenTypes.LinkedAlias */) {\n      return false;\n    }\n    peekSpaces(scnr);\n    const ret = scnr.currentPeek() === \".\" /* TokenChars.LinkedDot */;\n    scnr.resetPeek();\n    return ret;\n  }\n  function isLinkedModifierStart(scnr, context) {\n    const {\n      currentType\n    } = context;\n    if (currentType !== 8 /* TokenTypes.LinkedDot */) {\n      return false;\n    }\n    peekSpaces(scnr);\n    const ret = isIdentifierStart(scnr.currentPeek());\n    scnr.resetPeek();\n    return ret;\n  }\n  function isLinkedDelimiterStart(scnr, context) {\n    const {\n      currentType\n    } = context;\n    if (!(currentType === 7 /* TokenTypes.LinkedAlias */ || currentType === 11 /* TokenTypes.LinkedModifier */)) {\n      return false;\n    }\n    peekSpaces(scnr);\n    const ret = scnr.currentPeek() === \":\" /* TokenChars.LinkedDelimiter */;\n    scnr.resetPeek();\n    return ret;\n  }\n  function isLinkedReferStart(scnr, context) {\n    const {\n      currentType\n    } = context;\n    if (currentType !== 9 /* TokenTypes.LinkedDelimiter */) {\n      return false;\n    }\n    const fn = () => {\n      const ch = scnr.currentPeek();\n      if (ch === \"{\" /* TokenChars.BraceLeft */) {\n        return isIdentifierStart(scnr.peek());\n      } else if (ch === \"@\" /* TokenChars.LinkedAlias */ || ch === \"|\" /* TokenChars.Pipe */ || ch === \":\" /* TokenChars.LinkedDelimiter */ || ch === \".\" /* TokenChars.LinkedDot */ || ch === CHAR_SP || !ch) {\n        return false;\n      } else if (ch === CHAR_LF) {\n        scnr.peek();\n        return fn();\n      } else {\n        // other characters\n        return isTextStart(scnr, false);\n      }\n    };\n    const ret = fn();\n    scnr.resetPeek();\n    return ret;\n  }\n  function isPluralStart(scnr) {\n    peekSpaces(scnr);\n    const ret = scnr.currentPeek() === \"|\" /* TokenChars.Pipe */;\n    scnr.resetPeek();\n    return ret;\n  }\n  function isTextStart(scnr, reset = true) {\n    const fn = (hasSpace = false, prev = '') => {\n      const ch = scnr.currentPeek();\n      if (ch === \"{\" /* TokenChars.BraceLeft */) {\n        return hasSpace;\n      } else if (ch === \"@\" /* TokenChars.LinkedAlias */ || !ch) {\n        return hasSpace;\n      } else if (ch === \"|\" /* TokenChars.Pipe */) {\n        return !(prev === CHAR_SP || prev === CHAR_LF);\n      } else if (ch === CHAR_SP) {\n        scnr.peek();\n        return fn(true, CHAR_SP);\n      } else if (ch === CHAR_LF) {\n        scnr.peek();\n        return fn(true, CHAR_LF);\n      } else {\n        return true;\n      }\n    };\n    const ret = fn();\n    reset && scnr.resetPeek();\n    return ret;\n  }\n  function takeChar(scnr, fn) {\n    const ch = scnr.currentChar();\n    if (ch === EOF) {\n      return EOF;\n    }\n    if (fn(ch)) {\n      scnr.next();\n      return ch;\n    }\n    return null;\n  }\n  function isIdentifier(ch) {\n    const cc = ch.charCodeAt(0);\n    return cc >= 97 && cc <= 122 ||\n    // a-z\n    cc >= 65 && cc <= 90 ||\n    // A-Z\n    cc >= 48 && cc <= 57 ||\n    // 0-9\n    cc === 95 ||\n    // _\n    cc === 36 // $\n    ;\n  }\n  function takeIdentifierChar(scnr) {\n    return takeChar(scnr, isIdentifier);\n  }\n  function isNamedIdentifier(ch) {\n    const cc = ch.charCodeAt(0);\n    return cc >= 97 && cc <= 122 ||\n    // a-z\n    cc >= 65 && cc <= 90 ||\n    // A-Z\n    cc >= 48 && cc <= 57 ||\n    // 0-9\n    cc === 95 ||\n    // _\n    cc === 36 ||\n    // $\n    cc === 45 // -\n    ;\n  }\n  function takeNamedIdentifierChar(scnr) {\n    return takeChar(scnr, isNamedIdentifier);\n  }\n  function isDigit(ch) {\n    const cc = ch.charCodeAt(0);\n    return cc >= 48 && cc <= 57; // 0-9\n  }\n  function takeDigit(scnr) {\n    return takeChar(scnr, isDigit);\n  }\n  function isHexDigit(ch) {\n    const cc = ch.charCodeAt(0);\n    return cc >= 48 && cc <= 57 ||\n    // 0-9\n    cc >= 65 && cc <= 70 ||\n    // A-F\n    cc >= 97 && cc <= 102; // a-f\n  }\n  function takeHexDigit(scnr) {\n    return takeChar(scnr, isHexDigit);\n  }\n  function getDigits(scnr) {\n    let ch = '';\n    let num = '';\n    while (ch = takeDigit(scnr)) {\n      num += ch;\n    }\n    return num;\n  }\n  function readText(scnr) {\n    let buf = '';\n    while (true) {\n      const ch = scnr.currentChar();\n      if (ch === \"{\" /* TokenChars.BraceLeft */ || ch === \"}\" /* TokenChars.BraceRight */ || ch === \"@\" /* TokenChars.LinkedAlias */ || ch === \"|\" /* TokenChars.Pipe */ || !ch) {\n        break;\n      } else if (ch === CHAR_SP || ch === CHAR_LF) {\n        if (isTextStart(scnr)) {\n          buf += ch;\n          scnr.next();\n        } else if (isPluralStart(scnr)) {\n          break;\n        } else {\n          buf += ch;\n          scnr.next();\n        }\n      } else {\n        buf += ch;\n        scnr.next();\n      }\n    }\n    return buf;\n  }\n  function readNamedIdentifier(scnr) {\n    skipSpaces(scnr);\n    let ch = '';\n    let name = '';\n    while (ch = takeNamedIdentifierChar(scnr)) {\n      name += ch;\n    }\n    if (scnr.currentChar() === EOF) {\n      emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);\n    }\n    return name;\n  }\n  function readListIdentifier(scnr) {\n    skipSpaces(scnr);\n    let value = '';\n    if (scnr.currentChar() === '-') {\n      scnr.next();\n      value += `-${getDigits(scnr)}`;\n    } else {\n      value += getDigits(scnr);\n    }\n    if (scnr.currentChar() === EOF) {\n      emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);\n    }\n    return value;\n  }\n  function isLiteral(ch) {\n    return ch !== LITERAL_DELIMITER && ch !== CHAR_LF;\n  }\n  function readLiteral(scnr) {\n    skipSpaces(scnr);\n    // eslint-disable-next-line no-useless-escape\n    eat(scnr, `\\'`);\n    let ch = '';\n    let literal = '';\n    while (ch = takeChar(scnr, isLiteral)) {\n      if (ch === '\\\\') {\n        literal += readEscapeSequence(scnr);\n      } else {\n        literal += ch;\n      }\n    }\n    const current = scnr.currentChar();\n    if (current === CHAR_LF || current === EOF) {\n      emitError(CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER, currentPosition(), 0);\n      // TODO: Is it correct really?\n      if (current === CHAR_LF) {\n        scnr.next();\n        // eslint-disable-next-line no-useless-escape\n        eat(scnr, `\\'`);\n      }\n      return literal;\n    }\n    // eslint-disable-next-line no-useless-escape\n    eat(scnr, `\\'`);\n    return literal;\n  }\n  function readEscapeSequence(scnr) {\n    const ch = scnr.currentChar();\n    switch (ch) {\n      case '\\\\':\n      case `\\'`:\n        // eslint-disable-line no-useless-escape\n        scnr.next();\n        return `\\\\${ch}`;\n      case 'u':\n        return readUnicodeEscapeSequence(scnr, ch, 4);\n      case 'U':\n        return readUnicodeEscapeSequence(scnr, ch, 6);\n      default:\n        emitError(CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE, currentPosition(), 0, ch);\n        return '';\n    }\n  }\n  function readUnicodeEscapeSequence(scnr, unicode, digits) {\n    eat(scnr, unicode);\n    let sequence = '';\n    for (let i = 0; i < digits; i++) {\n      const ch = takeHexDigit(scnr);\n      if (!ch) {\n        emitError(CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE, currentPosition(), 0, `\\\\${unicode}${sequence}${scnr.currentChar()}`);\n        break;\n      }\n      sequence += ch;\n    }\n    return `\\\\${unicode}${sequence}`;\n  }\n  function isInvalidIdentifier(ch) {\n    return ch !== \"{\" /* TokenChars.BraceLeft */ && ch !== \"}\" /* TokenChars.BraceRight */ && ch !== CHAR_SP && ch !== CHAR_LF;\n  }\n  function readInvalidIdentifier(scnr) {\n    skipSpaces(scnr);\n    let ch = '';\n    let identifiers = '';\n    while (ch = takeChar(scnr, isInvalidIdentifier)) {\n      identifiers += ch;\n    }\n    return identifiers;\n  }\n  function readLinkedModifier(scnr) {\n    let ch = '';\n    let name = '';\n    while (ch = takeIdentifierChar(scnr)) {\n      name += ch;\n    }\n    return name;\n  }\n  function readLinkedRefer(scnr) {\n    const fn = buf => {\n      const ch = scnr.currentChar();\n      if (ch === \"{\" /* TokenChars.BraceLeft */ || ch === \"@\" /* TokenChars.LinkedAlias */ || ch === \"|\" /* TokenChars.Pipe */ || ch === \"(\" /* TokenChars.ParenLeft */ || ch === \")\" /* TokenChars.ParenRight */ || !ch) {\n        return buf;\n      } else if (ch === CHAR_SP) {\n        return buf;\n      } else if (ch === CHAR_LF || ch === DOT) {\n        buf += ch;\n        scnr.next();\n        return fn(buf);\n      } else {\n        buf += ch;\n        scnr.next();\n        return fn(buf);\n      }\n    };\n    return fn('');\n  }\n  function readPlural(scnr) {\n    skipSpaces(scnr);\n    const plural = eat(scnr, \"|\" /* TokenChars.Pipe */);\n    skipSpaces(scnr);\n    return plural;\n  }\n  // TODO: We need refactoring of token parsing ...\n  function readTokenInPlaceholder(scnr, context) {\n    let token = null;\n    const ch = scnr.currentChar();\n    switch (ch) {\n      case \"{\" /* TokenChars.BraceLeft */:\n        if (context.braceNest >= 1) {\n          emitError(CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER, currentPosition(), 0);\n        }\n        scnr.next();\n        token = getToken(context, 2 /* TokenTypes.BraceLeft */, \"{\" /* TokenChars.BraceLeft */);\n        skipSpaces(scnr);\n        context.braceNest++;\n        return token;\n      case \"}\" /* TokenChars.BraceRight */:\n        if (context.braceNest > 0 && context.currentType === 2 /* TokenTypes.BraceLeft */) {\n          emitError(CompileErrorCodes.EMPTY_PLACEHOLDER, currentPosition(), 0);\n        }\n        scnr.next();\n        token = getToken(context, 3 /* TokenTypes.BraceRight */, \"}\" /* TokenChars.BraceRight */);\n        context.braceNest--;\n        context.braceNest > 0 && skipSpaces(scnr);\n        if (context.inLinked && context.braceNest === 0) {\n          context.inLinked = false;\n        }\n        return token;\n      case \"@\" /* TokenChars.LinkedAlias */:\n        if (context.braceNest > 0) {\n          emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);\n        }\n        token = readTokenInLinked(scnr, context) || getEndToken(context);\n        context.braceNest = 0;\n        return token;\n      default:\n        {\n          let validNamedIdentifier = true;\n          let validListIdentifier = true;\n          let validLiteral = true;\n          if (isPluralStart(scnr)) {\n            if (context.braceNest > 0) {\n              emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);\n            }\n            token = getToken(context, 1 /* TokenTypes.Pipe */, readPlural(scnr));\n            // reset\n            context.braceNest = 0;\n            context.inLinked = false;\n            return token;\n          }\n          if (context.braceNest > 0 && (context.currentType === 4 /* TokenTypes.Named */ || context.currentType === 5 /* TokenTypes.List */ || context.currentType === 6 /* TokenTypes.Literal */)) {\n            emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);\n            context.braceNest = 0;\n            return readToken(scnr, context);\n          }\n          if (validNamedIdentifier = isNamedIdentifierStart(scnr, context)) {\n            token = getToken(context, 4 /* TokenTypes.Named */, readNamedIdentifier(scnr));\n            skipSpaces(scnr);\n            return token;\n          }\n          if (validListIdentifier = isListIdentifierStart(scnr, context)) {\n            token = getToken(context, 5 /* TokenTypes.List */, readListIdentifier(scnr));\n            skipSpaces(scnr);\n            return token;\n          }\n          if (validLiteral = isLiteralStart(scnr, context)) {\n            token = getToken(context, 6 /* TokenTypes.Literal */, readLiteral(scnr));\n            skipSpaces(scnr);\n            return token;\n          }\n          if (!validNamedIdentifier && !validListIdentifier && !validLiteral) {\n            // TODO: we should be re-designed invalid cases, when we will extend message syntax near the future ...\n            token = getToken(context, 12 /* TokenTypes.InvalidPlace */, readInvalidIdentifier(scnr));\n            emitError(CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER, currentPosition(), 0, token.value);\n            skipSpaces(scnr);\n            return token;\n          }\n          break;\n        }\n    }\n    return token;\n  }\n  // TODO: We need refactoring of token parsing ...\n  function readTokenInLinked(scnr, context) {\n    const {\n      currentType\n    } = context;\n    let token = null;\n    const ch = scnr.currentChar();\n    if ((currentType === 7 /* TokenTypes.LinkedAlias */ || currentType === 8 /* TokenTypes.LinkedDot */ || currentType === 11 /* TokenTypes.LinkedModifier */ || currentType === 9 /* TokenTypes.LinkedDelimiter */) && (ch === CHAR_LF || ch === CHAR_SP)) {\n      emitError(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);\n    }\n    switch (ch) {\n      case \"@\" /* TokenChars.LinkedAlias */:\n        scnr.next();\n        token = getToken(context, 7 /* TokenTypes.LinkedAlias */, \"@\" /* TokenChars.LinkedAlias */);\n        context.inLinked = true;\n        return token;\n      case \".\" /* TokenChars.LinkedDot */:\n        skipSpaces(scnr);\n        scnr.next();\n        return getToken(context, 8 /* TokenTypes.LinkedDot */, \".\" /* TokenChars.LinkedDot */);\n      case \":\" /* TokenChars.LinkedDelimiter */:\n        skipSpaces(scnr);\n        scnr.next();\n        return getToken(context, 9 /* TokenTypes.LinkedDelimiter */, \":\" /* TokenChars.LinkedDelimiter */);\n      default:\n        if (isPluralStart(scnr)) {\n          token = getToken(context, 1 /* TokenTypes.Pipe */, readPlural(scnr));\n          // reset\n          context.braceNest = 0;\n          context.inLinked = false;\n          return token;\n        }\n        if (isLinkedDotStart(scnr, context) || isLinkedDelimiterStart(scnr, context)) {\n          skipSpaces(scnr);\n          return readTokenInLinked(scnr, context);\n        }\n        if (isLinkedModifierStart(scnr, context)) {\n          skipSpaces(scnr);\n          return getToken(context, 11 /* TokenTypes.LinkedModifier */, readLinkedModifier(scnr));\n        }\n        if (isLinkedReferStart(scnr, context)) {\n          skipSpaces(scnr);\n          if (ch === \"{\" /* TokenChars.BraceLeft */) {\n            // scan the placeholder\n            return readTokenInPlaceholder(scnr, context) || token;\n          } else {\n            return getToken(context, 10 /* TokenTypes.LinkedKey */, readLinkedRefer(scnr));\n          }\n        }\n        if (currentType === 7 /* TokenTypes.LinkedAlias */) {\n          emitError(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);\n        }\n        context.braceNest = 0;\n        context.inLinked = false;\n        return readToken(scnr, context);\n    }\n  }\n  // TODO: We need refactoring of token parsing ...\n  function readToken(scnr, context) {\n    let token = {\n      type: 13 /* TokenTypes.EOF */\n    };\n    if (context.braceNest > 0) {\n      return readTokenInPlaceholder(scnr, context) || getEndToken(context);\n    }\n    if (context.inLinked) {\n      return readTokenInLinked(scnr, context) || getEndToken(context);\n    }\n    const ch = scnr.currentChar();\n    switch (ch) {\n      case \"{\" /* TokenChars.BraceLeft */:\n        return readTokenInPlaceholder(scnr, context) || getEndToken(context);\n      case \"}\" /* TokenChars.BraceRight */:\n        emitError(CompileErrorCodes.UNBALANCED_CLOSING_BRACE, currentPosition(), 0);\n        scnr.next();\n        return getToken(context, 3 /* TokenTypes.BraceRight */, \"}\" /* TokenChars.BraceRight */);\n      case \"@\" /* TokenChars.LinkedAlias */:\n        return readTokenInLinked(scnr, context) || getEndToken(context);\n      default:\n        {\n          if (isPluralStart(scnr)) {\n            token = getToken(context, 1 /* TokenTypes.Pipe */, readPlural(scnr));\n            // reset\n            context.braceNest = 0;\n            context.inLinked = false;\n            return token;\n          }\n          if (isTextStart(scnr)) {\n            return getToken(context, 0 /* TokenTypes.Text */, readText(scnr));\n          }\n          break;\n        }\n    }\n    return token;\n  }\n  function nextToken() {\n    const {\n      currentType,\n      offset,\n      startLoc,\n      endLoc\n    } = _context;\n    _context.lastType = currentType;\n    _context.lastOffset = offset;\n    _context.lastStartLoc = startLoc;\n    _context.lastEndLoc = endLoc;\n    _context.offset = currentOffset();\n    _context.startLoc = currentPosition();\n    if (_scnr.currentChar() === EOF) {\n      return getToken(_context, 13 /* TokenTypes.EOF */);\n    }\n    return readToken(_scnr, _context);\n  }\n  return {\n    nextToken,\n    currentOffset,\n    currentPosition,\n    context\n  };\n}\nconst ERROR_DOMAIN = 'parser';\n// Backslash backslash, backslash quote, uHHHH, UHHHHHH.\nconst KNOWN_ESCAPES = /(?:\\\\\\\\|\\\\'|\\\\u([0-9a-fA-F]{4})|\\\\U([0-9a-fA-F]{6}))/g;\nfunction fromEscapeSequence(match, codePoint4, codePoint6) {\n  switch (match) {\n    case `\\\\\\\\`:\n      return `\\\\`;\n    // eslint-disable-next-line no-useless-escape\n    case `\\\\\\'`:\n      // eslint-disable-next-line no-useless-escape\n      return `\\'`;\n    default:\n      {\n        const codePoint = parseInt(codePoint4 || codePoint6, 16);\n        if (codePoint <= 0xd7ff || codePoint >= 0xe000) {\n          return String.fromCodePoint(codePoint);\n        }\n        // invalid ...\n        // Replace them with U+FFFD REPLACEMENT CHARACTER.\n        return '�';\n      }\n  }\n}\nfunction createParser(options = {}) {\n  const location = options.location !== false;\n  const {\n    onError\n  } = options;\n  function emitError(tokenzer, code, start, offset, ...args) {\n    const end = tokenzer.currentPosition();\n    end.offset += offset;\n    end.column += offset;\n    if (onError) {\n      const loc = location ? createLocation(start, end) : null;\n      const err = createCompileError(code, loc, {\n        domain: ERROR_DOMAIN,\n        args\n      });\n      onError(err);\n    }\n  }\n  function startNode(type, offset, loc) {\n    const node = {\n      type\n    };\n    if (location) {\n      node.start = offset;\n      node.end = offset;\n      node.loc = {\n        start: loc,\n        end: loc\n      };\n    }\n    return node;\n  }\n  function endNode(node, offset, pos, type) {\n    if (location) {\n      node.end = offset;\n      if (node.loc) {\n        node.loc.end = pos;\n      }\n    }\n  }\n  function parseText(tokenizer, value) {\n    const context = tokenizer.context();\n    const node = startNode(3 /* NodeTypes.Text */, context.offset, context.startLoc);\n    node.value = value;\n    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n    return node;\n  }\n  function parseList(tokenizer, index) {\n    const context = tokenizer.context();\n    const {\n      lastOffset: offset,\n      lastStartLoc: loc\n    } = context; // get brace left loc\n    const node = startNode(5 /* NodeTypes.List */, offset, loc);\n    node.index = parseInt(index, 10);\n    tokenizer.nextToken(); // skip brach right\n    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n    return node;\n  }\n  function parseNamed(tokenizer, key) {\n    const context = tokenizer.context();\n    const {\n      lastOffset: offset,\n      lastStartLoc: loc\n    } = context; // get brace left loc\n    const node = startNode(4 /* NodeTypes.Named */, offset, loc);\n    node.key = key;\n    tokenizer.nextToken(); // skip brach right\n    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n    return node;\n  }\n  function parseLiteral(tokenizer, value) {\n    const context = tokenizer.context();\n    const {\n      lastOffset: offset,\n      lastStartLoc: loc\n    } = context; // get brace left loc\n    const node = startNode(9 /* NodeTypes.Literal */, offset, loc);\n    node.value = value.replace(KNOWN_ESCAPES, fromEscapeSequence);\n    tokenizer.nextToken(); // skip brach right\n    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n    return node;\n  }\n  function parseLinkedModifier(tokenizer) {\n    const token = tokenizer.nextToken();\n    const context = tokenizer.context();\n    const {\n      lastOffset: offset,\n      lastStartLoc: loc\n    } = context; // get linked dot loc\n    const node = startNode(8 /* NodeTypes.LinkedModifier */, offset, loc);\n    if (token.type !== 11 /* TokenTypes.LinkedModifier */) {\n      // empty modifier\n      emitError(tokenizer, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER, context.lastStartLoc, 0);\n      node.value = '';\n      endNode(node, offset, loc);\n      return {\n        nextConsumeToken: token,\n        node\n      };\n    }\n    // check token\n    if (token.value == null) {\n      emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n    }\n    node.value = token.value || '';\n    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n    return {\n      node\n    };\n  }\n  function parseLinkedKey(tokenizer, value) {\n    const context = tokenizer.context();\n    const node = startNode(7 /* NodeTypes.LinkedKey */, context.offset, context.startLoc);\n    node.value = value;\n    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n    return node;\n  }\n  function parseLinked(tokenizer) {\n    const context = tokenizer.context();\n    const linkedNode = startNode(6 /* NodeTypes.Linked */, context.offset, context.startLoc);\n    let token = tokenizer.nextToken();\n    if (token.type === 8 /* TokenTypes.LinkedDot */) {\n      const parsed = parseLinkedModifier(tokenizer);\n      linkedNode.modifier = parsed.node;\n      token = parsed.nextConsumeToken || tokenizer.nextToken();\n    }\n    // asset check token\n    if (token.type !== 9 /* TokenTypes.LinkedDelimiter */) {\n      emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n    }\n    token = tokenizer.nextToken();\n    // skip brace left\n    if (token.type === 2 /* TokenTypes.BraceLeft */) {\n      token = tokenizer.nextToken();\n    }\n    switch (token.type) {\n      case 10 /* TokenTypes.LinkedKey */:\n        if (token.value == null) {\n          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n        }\n        linkedNode.key = parseLinkedKey(tokenizer, token.value || '');\n        break;\n      case 4 /* TokenTypes.Named */:\n        if (token.value == null) {\n          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n        }\n        linkedNode.key = parseNamed(tokenizer, token.value || '');\n        break;\n      case 5 /* TokenTypes.List */:\n        if (token.value == null) {\n          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n        }\n        linkedNode.key = parseList(tokenizer, token.value || '');\n        break;\n      case 6 /* TokenTypes.Literal */:\n        if (token.value == null) {\n          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n        }\n        linkedNode.key = parseLiteral(tokenizer, token.value || '');\n        break;\n      default:\n        {\n          // empty key\n          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY, context.lastStartLoc, 0);\n          const nextContext = tokenizer.context();\n          const emptyLinkedKeyNode = startNode(7 /* NodeTypes.LinkedKey */, nextContext.offset, nextContext.startLoc);\n          emptyLinkedKeyNode.value = '';\n          endNode(emptyLinkedKeyNode, nextContext.offset, nextContext.startLoc);\n          linkedNode.key = emptyLinkedKeyNode;\n          endNode(linkedNode, nextContext.offset, nextContext.startLoc);\n          return {\n            nextConsumeToken: token,\n            node: linkedNode\n          };\n        }\n    }\n    endNode(linkedNode, tokenizer.currentOffset(), tokenizer.currentPosition());\n    return {\n      node: linkedNode\n    };\n  }\n  function parseMessage(tokenizer) {\n    const context = tokenizer.context();\n    const startOffset = context.currentType === 1 /* TokenTypes.Pipe */ ? tokenizer.currentOffset() : context.offset;\n    const startLoc = context.currentType === 1 /* TokenTypes.Pipe */ ? context.endLoc : context.startLoc;\n    const node = startNode(2 /* NodeTypes.Message */, startOffset, startLoc);\n    node.items = [];\n    let nextToken = null;\n    do {\n      const token = nextToken || tokenizer.nextToken();\n      nextToken = null;\n      switch (token.type) {\n        case 0 /* TokenTypes.Text */:\n          if (token.value == null) {\n            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n          }\n          node.items.push(parseText(tokenizer, token.value || ''));\n          break;\n        case 5 /* TokenTypes.List */:\n          if (token.value == null) {\n            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n          }\n          node.items.push(parseList(tokenizer, token.value || ''));\n          break;\n        case 4 /* TokenTypes.Named */:\n          if (token.value == null) {\n            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n          }\n          node.items.push(parseNamed(tokenizer, token.value || ''));\n          break;\n        case 6 /* TokenTypes.Literal */:\n          if (token.value == null) {\n            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n          }\n          node.items.push(parseLiteral(tokenizer, token.value || ''));\n          break;\n        case 7 /* TokenTypes.LinkedAlias */:\n          {\n            const parsed = parseLinked(tokenizer);\n            node.items.push(parsed.node);\n            nextToken = parsed.nextConsumeToken || null;\n            break;\n          }\n      }\n    } while (context.currentType !== 13 /* TokenTypes.EOF */ && context.currentType !== 1 /* TokenTypes.Pipe */);\n    // adjust message node loc\n    const endOffset = context.currentType === 1 /* TokenTypes.Pipe */ ? context.lastOffset : tokenizer.currentOffset();\n    const endLoc = context.currentType === 1 /* TokenTypes.Pipe */ ? context.lastEndLoc : tokenizer.currentPosition();\n    endNode(node, endOffset, endLoc);\n    return node;\n  }\n  function parsePlural(tokenizer, offset, loc, msgNode) {\n    const context = tokenizer.context();\n    let hasEmptyMessage = msgNode.items.length === 0;\n    const node = startNode(1 /* NodeTypes.Plural */, offset, loc);\n    node.cases = [];\n    node.cases.push(msgNode);\n    do {\n      const msg = parseMessage(tokenizer);\n      if (!hasEmptyMessage) {\n        hasEmptyMessage = msg.items.length === 0;\n      }\n      node.cases.push(msg);\n    } while (context.currentType !== 13 /* TokenTypes.EOF */);\n    if (hasEmptyMessage) {\n      emitError(tokenizer, CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL, loc, 0);\n    }\n    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n    return node;\n  }\n  function parseResource(tokenizer) {\n    const context = tokenizer.context();\n    const {\n      offset,\n      startLoc\n    } = context;\n    const msgNode = parseMessage(tokenizer);\n    if (context.currentType === 13 /* TokenTypes.EOF */) {\n      return msgNode;\n    } else {\n      return parsePlural(tokenizer, offset, startLoc, msgNode);\n    }\n  }\n  function parse(source) {\n    const tokenizer = createTokenizer(source, assign({}, options));\n    const context = tokenizer.context();\n    const node = startNode(0 /* NodeTypes.Resource */, context.offset, context.startLoc);\n    if (location && node.loc) {\n      node.loc.source = source;\n    }\n    node.body = parseResource(tokenizer);\n    if (options.onCacheKey) {\n      node.cacheKey = options.onCacheKey(source);\n    }\n    // assert whether achieved to EOF\n    if (context.currentType !== 13 /* TokenTypes.EOF */) {\n      emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, source[context.offset] || '');\n    }\n    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n    return node;\n  }\n  return {\n    parse\n  };\n}\nfunction getTokenCaption(token) {\n  if (token.type === 13 /* TokenTypes.EOF */) {\n    return 'EOF';\n  }\n  const name = (token.value || '').replace(/\\r?\\n/gu, '\\\\n');\n  return name.length > 10 ? name.slice(0, 9) + '…' : name;\n}\nfunction createTransformer(ast, options = {} // eslint-disable-line\n) {\n  const _context = {\n    ast,\n    helpers: new Set()\n  };\n  const context = () => _context;\n  const helper = name => {\n    _context.helpers.add(name);\n    return name;\n  };\n  return {\n    context,\n    helper\n  };\n}\nfunction traverseNodes(nodes, transformer) {\n  for (let i = 0; i < nodes.length; i++) {\n    traverseNode(nodes[i], transformer);\n  }\n}\nfunction traverseNode(node, transformer) {\n  // TODO: if we need pre-hook of transform, should be implemented to here\n  switch (node.type) {\n    case 1 /* NodeTypes.Plural */:\n      traverseNodes(node.cases, transformer);\n      transformer.helper(\"plural\" /* HelperNameMap.PLURAL */);\n      break;\n    case 2 /* NodeTypes.Message */:\n      traverseNodes(node.items, transformer);\n      break;\n    case 6 /* NodeTypes.Linked */:\n      {\n        const linked = node;\n        traverseNode(linked.key, transformer);\n        transformer.helper(\"linked\" /* HelperNameMap.LINKED */);\n        transformer.helper(\"type\" /* HelperNameMap.TYPE */);\n        break;\n      }\n    case 5 /* NodeTypes.List */:\n      transformer.helper(\"interpolate\" /* HelperNameMap.INTERPOLATE */);\n      transformer.helper(\"list\" /* HelperNameMap.LIST */);\n      break;\n    case 4 /* NodeTypes.Named */:\n      transformer.helper(\"interpolate\" /* HelperNameMap.INTERPOLATE */);\n      transformer.helper(\"named\" /* HelperNameMap.NAMED */);\n      break;\n  }\n  // TODO: if we need post-hook of transform, should be implemented to here\n}\n// transform AST\nfunction transform(ast, options = {} // eslint-disable-line\n) {\n  const transformer = createTransformer(ast);\n  transformer.helper(\"normalize\" /* HelperNameMap.NORMALIZE */);\n  // traverse\n  ast.body && traverseNode(ast.body, transformer);\n  // set meta information\n  const context = transformer.context();\n  ast.helpers = Array.from(context.helpers);\n}\nfunction baseCompile(source, options = {}) {\n  const assignedOptions = assign({}, options);\n  const jit = !!assignedOptions.jit;\n  const enableMangle = !!assignedOptions.mangle;\n  const enableOptimize = assignedOptions.optimize == null ? true : assignedOptions.optimize;\n  // parse source codes\n  const parser = createParser(assignedOptions);\n  const ast = parser.parse(source);\n  // TODO:\n  // With the introduction of Jit compilation, code generation is no longer necessary. This function may no longer be needed since tree-shaking is not possible.\n  if (!jit) {\n    // transform ASTs\n    transform(ast, assignedOptions);\n    // generate javascript codes\n    return generate(ast, assignedOptions);\n  } else {\n    // optimize ASTs\n    enableOptimize && optimize(ast);\n    // minimize ASTs\n    enableMangle && mangle(ast);\n    // In JIT mode, no ast transform, no code generation.\n    return {\n      ast,\n      code: ''\n    };\n  }\n}\n\n// eslint-disable-next-line no-useless-escape\nconst RE_HTML_TAG = /<\\/?[\\w\\s=\"/.':;#-\\/]+>/;\nconst detectHtmlTag = source => RE_HTML_TAG.test(source);\nexport { COMPILE_ERROR_CODES_EXTEND_POINT, CompileErrorCodes, ERROR_DOMAIN, LOCATION_STUB, baseCompile, createCompileError, createLocation, createParser, createPosition, defaultOnError, detectHtmlTag, errorMessages, mangle, optimize };","map":{"version":3,"names":["format","isString","join","assign","LOCATION_STUB","start","line","column","offset","end","createPosition","createLocation","source","loc","CompileErrorCodes","EXPECTED_TOKEN","INVALID_TOKEN_IN_PLACEHOLDER","UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER","UNKNOWN_ESCAPE_SEQUENCE","INVALID_UNICODE_ESCAPE_SEQUENCE","UNBALANCED_CLOSING_BRACE","UNTERMINATED_CLOSING_BRACE","EMPTY_PLACEHOLDER","NOT_ALLOW_NEST_PLACEHOLDER","INVALID_LINKED_FORMAT","MUST_HAVE_MESSAGES_IN_PLURAL","UNEXPECTED_EMPTY_LINKED_MODIFIER","UNEXPECTED_EMPTY_LINKED_KEY","UNEXPECTED_LEXICAL_ANALYSIS","UNHANDLED_CODEGEN_NODE_TYPE","UNHANDLED_MINIFIER_NODE_TYPE","COMPILE_ERROR_CODES_EXTEND_POINT","errorMessages","createCompileError","code","options","domain","messages","args","msg","process","env","NODE_ENV","error","SyntaxError","String","location","defaultOnError","ERROR_DOMAIN$3","createCodeGenerator","ast","sourceMap","filename","breakLineCode","needIndent","_needIndent","_context","map","undefined","indentLevel","context","push","node","_newline","n","withBreakLine","_breakLineCode","repeat","indent","withNewLine","level","deindent","newline","helper","key","generateLinkedNode","generator","generateNode","modifier","generateMessageNode","length","items","i","generatePluralNode","cases","generateResource","body","type","JSON","stringify","value","index","generate","mode","helpers","s","toJSON","ERROR_DOMAIN$2","mangle","t","resource","b","plural","c","message","static","valueNode","v","linked","k","m","list","named","optimize","optimizeMessageNode","forEach","item","values","CHAR_SP","CHAR_CR","CHAR_LF","CHAR_LS","fromCharCode","CHAR_PS","createScanner","str","_buf","_index","_line","_column","_peekOffset","isCRLF","isLF","isPS","isLS","isLineEnd","peekOffset","charAt","currentChar","currentPeek","next","peek","reset","resetPeek","skipToPeek","target","EOF","DOT","LITERAL_DELIMITER","ERROR_DOMAIN$1","createTokenizer","_scnr","currentOffset","currentPosition","_initLoc","_initOffset","currentType","startLoc","endLoc","lastType","lastOffset","lastStartLoc","lastEndLoc","braceNest","inLinked","text","onError","emitError","pos","ctx","err","getToken","token","getEndToken","eat","scnr","ch","peekSpaces","buf","skipSpaces","isIdentifierStart","cc","charCodeAt","isNumberStart","isNamedIdentifierStart","ret","isListIdentifierStart","isLiteralStart","isLinkedDotStart","isLinkedModifierStart","isLinkedDelimiterStart","isLinkedReferStart","fn","isTextStart","isPluralStart","hasSpace","prev","takeChar","isIdentifier","takeIdentifierChar","isNamedIdentifier","takeNamedIdentifierChar","isDigit","takeDigit","isHexDigit","takeHexDigit","getDigits","num","readText","readNamedIdentifier","name","readListIdentifier","isLiteral","readLiteral","literal","readEscapeSequence","current","readUnicodeEscapeSequence","unicode","digits","sequence","isInvalidIdentifier","readInvalidIdentifier","identifiers","readLinkedModifier","readLinkedRefer","readPlural","readTokenInPlaceholder","readTokenInLinked","validNamedIdentifier","validListIdentifier","validLiteral","readToken","nextToken","ERROR_DOMAIN","KNOWN_ESCAPES","fromEscapeSequence","match","codePoint4","codePoint6","codePoint","parseInt","fromCodePoint","createParser","tokenzer","startNode","endNode","parseText","tokenizer","parseList","parseNamed","parseLiteral","replace","parseLinkedModifier","nextConsumeToken","getTokenCaption","parseLinkedKey","parseLinked","linkedNode","parsed","nextContext","emptyLinkedKeyNode","parseMessage","startOffset","endOffset","parsePlural","msgNode","hasEmptyMessage","parseResource","parse","onCacheKey","cacheKey","slice","createTransformer","Set","add","traverseNodes","nodes","transformer","traverseNode","transform","Array","from","baseCompile","assignedOptions","jit","enableMangle","enableOptimize","parser","RE_HTML_TAG","detectHtmlTag","test"],"sources":["C:/Users/Administrator/Desktop/flyboot/node_modules/@intlify/message-compiler/dist/message-compiler.js"],"sourcesContent":["/*!\n  * message-compiler v12.0.0-alpha.2\n  * (c) 2016-present kazuya kawaguchi and contributors\n  * Released under the MIT License.\n  */\nimport { format, isString, join, assign } from '@intlify/shared';\n\nconst LOCATION_STUB = {\n    start: { line: 1, column: 1, offset: 0 },\n    end: { line: 1, column: 1, offset: 0 }\n};\nfunction createPosition(line, column, offset) {\n    return { line, column, offset };\n}\nfunction createLocation(start, end, source) {\n    const loc = { start, end };\n    if (source != null) {\n        loc.source = source;\n    }\n    return loc;\n}\n\nconst CompileErrorCodes = {\n    // tokenizer error codes\n    EXPECTED_TOKEN: 1,\n    INVALID_TOKEN_IN_PLACEHOLDER: 2,\n    UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER: 3,\n    UNKNOWN_ESCAPE_SEQUENCE: 4,\n    INVALID_UNICODE_ESCAPE_SEQUENCE: 5,\n    UNBALANCED_CLOSING_BRACE: 6,\n    UNTERMINATED_CLOSING_BRACE: 7,\n    EMPTY_PLACEHOLDER: 8,\n    NOT_ALLOW_NEST_PLACEHOLDER: 9,\n    INVALID_LINKED_FORMAT: 10,\n    // parser error codes\n    MUST_HAVE_MESSAGES_IN_PLURAL: 11,\n    UNEXPECTED_EMPTY_LINKED_MODIFIER: 12,\n    UNEXPECTED_EMPTY_LINKED_KEY: 13,\n    UNEXPECTED_LEXICAL_ANALYSIS: 14,\n    // generator error codes\n    UNHANDLED_CODEGEN_NODE_TYPE: 15,\n    // minifier error codes\n    UNHANDLED_MINIFIER_NODE_TYPE: 16\n};\n// Special value for higher-order compilers to pick up the last code\n// to avoid collision of error codes.\n// This should always be kept as the last item.\nconst COMPILE_ERROR_CODES_EXTEND_POINT = 17;\n/** @internal */\nconst errorMessages = {\n    // tokenizer error messages\n    [CompileErrorCodes.EXPECTED_TOKEN]: `Expected token: '{0}'`,\n    [CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER]: `Invalid token in placeholder: '{0}'`,\n    [CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER]: `Unterminated single quote in placeholder`,\n    [CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE]: `Unknown escape sequence: \\\\{0}`,\n    [CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE]: `Invalid unicode escape sequence: {0}`,\n    [CompileErrorCodes.UNBALANCED_CLOSING_BRACE]: `Unbalanced closing brace`,\n    [CompileErrorCodes.UNTERMINATED_CLOSING_BRACE]: `Unterminated closing brace`,\n    [CompileErrorCodes.EMPTY_PLACEHOLDER]: `Empty placeholder`,\n    [CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER]: `Not allowed nest placeholder`,\n    [CompileErrorCodes.INVALID_LINKED_FORMAT]: `Invalid linked format`,\n    // parser error messages\n    [CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL]: `Plural must have messages`,\n    [CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER]: `Unexpected empty linked modifier`,\n    [CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY]: `Unexpected empty linked key`,\n    [CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS]: `Unexpected lexical analysis in token: '{0}'`,\n    // generator error messages\n    [CompileErrorCodes.UNHANDLED_CODEGEN_NODE_TYPE]: `unhandled codegen node type: '{0}'`,\n    // minimizer error messages\n    [CompileErrorCodes.UNHANDLED_MINIFIER_NODE_TYPE]: `unhandled mimifier node type: '{0}'`\n};\nfunction createCompileError(code, loc, options = {}) {\n    const { domain, messages, args } = options;\n    const msg = (process.env.NODE_ENV !== 'production')\n        ? format((messages || errorMessages)[code] || '', ...(args || []))\n        : code;\n    const error = new SyntaxError(String(msg));\n    error.code = code;\n    if (loc) {\n        error.location = loc;\n    }\n    error.domain = domain;\n    return error;\n}\n/** @internal */\nfunction defaultOnError(error) {\n    throw error;\n}\n\n// eslint-disable-next-line @typescript-eslint/triple-slash-reference\n/// <reference types=\"source-map-js\" />\nconst ERROR_DOMAIN$3 = 'parser';\nfunction createCodeGenerator(ast, options) {\n    const { sourceMap, filename, breakLineCode, needIndent: _needIndent } = options;\n    const location = options.location !== false;\n    const _context = {\n        filename,\n        code: '',\n        column: 1,\n        line: 1,\n        offset: 0,\n        map: undefined,\n        breakLineCode,\n        needIndent: _needIndent,\n        indentLevel: 0\n    };\n    if (location && ast.loc) {\n        _context.source = ast.loc.source;\n    }\n    const context = () => _context;\n    function push(code, node) {\n        _context.code += code;\n    }\n    function _newline(n, withBreakLine = true) {\n        const _breakLineCode = withBreakLine ? breakLineCode : '';\n        push(_needIndent ? _breakLineCode + `  `.repeat(n) : _breakLineCode);\n    }\n    function indent(withNewLine = true) {\n        const level = ++_context.indentLevel;\n        withNewLine && _newline(level);\n    }\n    function deindent(withNewLine = true) {\n        const level = --_context.indentLevel;\n        withNewLine && _newline(level);\n    }\n    function newline() {\n        _newline(_context.indentLevel);\n    }\n    const helper = (key) => `_${key}`;\n    const needIndent = () => _context.needIndent;\n    return {\n        context,\n        push,\n        indent,\n        deindent,\n        newline,\n        helper,\n        needIndent\n    };\n}\nfunction generateLinkedNode(generator, node) {\n    const { helper } = generator;\n    generator.push(`${helper(\"linked\" /* HelperNameMap.LINKED */)}(`);\n    generateNode(generator, node.key);\n    if (node.modifier) {\n        generator.push(`, `);\n        generateNode(generator, node.modifier);\n        generator.push(`, _type`);\n    }\n    else {\n        generator.push(`, undefined, _type`);\n    }\n    generator.push(`)`);\n}\nfunction generateMessageNode(generator, node) {\n    const { helper, needIndent } = generator;\n    generator.push(`${helper(\"normalize\" /* HelperNameMap.NORMALIZE */)}([`);\n    generator.indent(needIndent());\n    const length = node.items.length;\n    for (let i = 0; i < length; i++) {\n        generateNode(generator, node.items[i]);\n        if (i === length - 1) {\n            break;\n        }\n        generator.push(', ');\n    }\n    generator.deindent(needIndent());\n    generator.push('])');\n}\nfunction generatePluralNode(generator, node) {\n    const { helper, needIndent } = generator;\n    if (node.cases.length > 1) {\n        generator.push(`${helper(\"plural\" /* HelperNameMap.PLURAL */)}([`);\n        generator.indent(needIndent());\n        const length = node.cases.length;\n        for (let i = 0; i < length; i++) {\n            generateNode(generator, node.cases[i]);\n            if (i === length - 1) {\n                break;\n            }\n            generator.push(', ');\n        }\n        generator.deindent(needIndent());\n        generator.push(`])`);\n    }\n}\nfunction generateResource(generator, node) {\n    if (node.body) {\n        generateNode(generator, node.body);\n    }\n    else {\n        generator.push('null');\n    }\n}\nfunction generateNode(generator, node) {\n    const { helper } = generator;\n    switch (node.type) {\n        case 0 /* NodeTypes.Resource */:\n            generateResource(generator, node);\n            break;\n        case 1 /* NodeTypes.Plural */:\n            generatePluralNode(generator, node);\n            break;\n        case 2 /* NodeTypes.Message */:\n            generateMessageNode(generator, node);\n            break;\n        case 6 /* NodeTypes.Linked */:\n            generateLinkedNode(generator, node);\n            break;\n        case 8 /* NodeTypes.LinkedModifier */:\n            generator.push(JSON.stringify(node.value), node);\n            break;\n        case 7 /* NodeTypes.LinkedKey */:\n            generator.push(JSON.stringify(node.value), node);\n            break;\n        case 5 /* NodeTypes.List */:\n            generator.push(`${helper(\"interpolate\" /* HelperNameMap.INTERPOLATE */)}(${helper(\"list\" /* HelperNameMap.LIST */)}(${node.index}))`, node);\n            break;\n        case 4 /* NodeTypes.Named */:\n            generator.push(`${helper(\"interpolate\" /* HelperNameMap.INTERPOLATE */)}(${helper(\"named\" /* HelperNameMap.NAMED */)}(${JSON.stringify(node.key)}))`, node);\n            break;\n        case 9 /* NodeTypes.Literal */:\n            generator.push(JSON.stringify(node.value), node);\n            break;\n        case 3 /* NodeTypes.Text */:\n            generator.push(JSON.stringify(node.value), node);\n            break;\n        default:\n            if ((process.env.NODE_ENV !== 'production')) {\n                throw createCompileError(CompileErrorCodes.UNHANDLED_CODEGEN_NODE_TYPE, null, {\n                    domain: ERROR_DOMAIN$3,\n                    args: [node.type]\n                });\n            }\n    }\n}\n// generate code from AST\nconst generate = (ast, options = {}) => {\n    const mode = isString(options.mode) ? options.mode : 'normal';\n    const filename = isString(options.filename)\n        ? options.filename\n        : 'message.intl';\n    const sourceMap = !!options.sourceMap;\n    // prettier-ignore\n    const breakLineCode = options.breakLineCode != null\n        ? options.breakLineCode\n        : mode === 'arrow'\n            ? ';'\n            : '\\n';\n    const needIndent = options.needIndent ? options.needIndent : mode !== 'arrow';\n    const helpers = ast.helpers || [];\n    const generator = createCodeGenerator(ast, {\n        mode,\n        filename,\n        sourceMap,\n        breakLineCode,\n        needIndent\n    });\n    generator.push(mode === 'normal' ? `function __msg__ (ctx) {` : `(ctx) => {`);\n    generator.indent(needIndent);\n    if (helpers.length > 0) {\n        generator.push(`const { ${join(helpers.map(s => `${s}: _${s}`), ', ')} } = ctx`);\n        generator.newline();\n    }\n    generator.push(`return `);\n    generateNode(generator, ast);\n    generator.deindent(needIndent);\n    generator.push(`}`);\n    delete ast.helpers;\n    const { code, map } = generator.context();\n    return {\n        ast,\n        code,\n        map: map ? map.toJSON() : undefined // eslint-disable-line @typescript-eslint/no-explicit-any\n    };\n};\n\nconst ERROR_DOMAIN$2 = 'minifier';\n/* eslint-disable @typescript-eslint/no-explicit-any */\nfunction mangle(node) {\n    node.t = node.type;\n    switch (node.type) {\n        case 0 /* NodeTypes.Resource */: {\n            const resource = node;\n            mangle(resource.body);\n            resource.b = resource.body;\n            delete resource.body;\n            break;\n        }\n        case 1 /* NodeTypes.Plural */: {\n            const plural = node;\n            const cases = plural.cases;\n            for (let i = 0; i < cases.length; i++) {\n                mangle(cases[i]);\n            }\n            plural.c = cases;\n            delete plural.cases;\n            break;\n        }\n        case 2 /* NodeTypes.Message */: {\n            const message = node;\n            const items = message.items;\n            for (let i = 0; i < items.length; i++) {\n                mangle(items[i]);\n            }\n            message.i = items;\n            delete message.items;\n            if (message.static) {\n                message.s = message.static;\n                delete message.static;\n            }\n            break;\n        }\n        case 3 /* NodeTypes.Text */:\n        case 9 /* NodeTypes.Literal */:\n        case 8 /* NodeTypes.LinkedModifier */:\n        case 7 /* NodeTypes.LinkedKey */: {\n            const valueNode = node;\n            if (valueNode.value) {\n                valueNode.v = valueNode.value;\n                delete valueNode.value;\n            }\n            break;\n        }\n        case 6 /* NodeTypes.Linked */: {\n            const linked = node;\n            mangle(linked.key);\n            linked.k = linked.key;\n            delete linked.key;\n            if (linked.modifier) {\n                mangle(linked.modifier);\n                linked.m = linked.modifier;\n                delete linked.modifier;\n            }\n            break;\n        }\n        case 5 /* NodeTypes.List */: {\n            const list = node;\n            list.i = list.index;\n            delete list.index;\n            break;\n        }\n        case 4 /* NodeTypes.Named */: {\n            const named = node;\n            named.k = named.key;\n            delete named.key;\n            break;\n        }\n        default:\n            if ((process.env.NODE_ENV !== 'production')) {\n                throw createCompileError(CompileErrorCodes.UNHANDLED_MINIFIER_NODE_TYPE, null, {\n                    domain: ERROR_DOMAIN$2,\n                    args: [node.type]\n                });\n            }\n    }\n    delete node.type;\n}\n/* eslint-enable @typescript-eslint/no-explicit-any */\n\nfunction optimize(ast) {\n    const body = ast.body;\n    if (body.type === 2 /* NodeTypes.Message */) {\n        optimizeMessageNode(body);\n    }\n    else {\n        body.cases.forEach(c => optimizeMessageNode(c));\n    }\n    return ast;\n}\nfunction optimizeMessageNode(message) {\n    if (message.items.length === 1) {\n        const item = message.items[0];\n        if (item.type === 3 /* NodeTypes.Text */ || item.type === 9 /* NodeTypes.Literal */) {\n            message.static = item.value;\n            delete item.value; // optimization for size\n        }\n    }\n    else {\n        const values = [];\n        for (let i = 0; i < message.items.length; i++) {\n            const item = message.items[i];\n            if (!(item.type === 3 /* NodeTypes.Text */ || item.type === 9 /* NodeTypes.Literal */)) {\n                break;\n            }\n            if (item.value == null) {\n                break;\n            }\n            values.push(item.value);\n        }\n        if (values.length === message.items.length) {\n            message.static = join(values);\n            for (let i = 0; i < message.items.length; i++) {\n                const item = message.items[i];\n                if (item.type === 3 /* NodeTypes.Text */ || item.type === 9 /* NodeTypes.Literal */) {\n                    delete item.value; // optimization for size\n                }\n            }\n        }\n    }\n}\n\nconst CHAR_SP = ' ';\nconst CHAR_CR = '\\r';\nconst CHAR_LF = '\\n';\nconst CHAR_LS = String.fromCharCode(0x2028);\nconst CHAR_PS = String.fromCharCode(0x2029);\nfunction createScanner(str) {\n    const _buf = str;\n    let _index = 0;\n    let _line = 1;\n    let _column = 1;\n    let _peekOffset = 0;\n    const isCRLF = (index) => _buf[index] === CHAR_CR && _buf[index + 1] === CHAR_LF;\n    const isLF = (index) => _buf[index] === CHAR_LF;\n    const isPS = (index) => _buf[index] === CHAR_PS;\n    const isLS = (index) => _buf[index] === CHAR_LS;\n    const isLineEnd = (index) => isCRLF(index) || isLF(index) || isPS(index) || isLS(index);\n    const index = () => _index;\n    const line = () => _line;\n    const column = () => _column;\n    const peekOffset = () => _peekOffset;\n    const charAt = (offset) => isCRLF(offset) || isPS(offset) || isLS(offset) ? CHAR_LF : _buf[offset];\n    const currentChar = () => charAt(_index);\n    const currentPeek = () => charAt(_index + _peekOffset);\n    function next() {\n        _peekOffset = 0;\n        if (isLineEnd(_index)) {\n            _line++;\n            _column = 0;\n        }\n        if (isCRLF(_index)) {\n            _index++;\n        }\n        _index++;\n        _column++;\n        return _buf[_index];\n    }\n    function peek() {\n        if (isCRLF(_index + _peekOffset)) {\n            _peekOffset++;\n        }\n        _peekOffset++;\n        return _buf[_index + _peekOffset];\n    }\n    function reset() {\n        _index = 0;\n        _line = 1;\n        _column = 1;\n        _peekOffset = 0;\n    }\n    function resetPeek(offset = 0) {\n        _peekOffset = offset;\n    }\n    function skipToPeek() {\n        const target = _index + _peekOffset;\n        while (target !== _index) {\n            next();\n        }\n        _peekOffset = 0;\n    }\n    return {\n        index,\n        line,\n        column,\n        peekOffset,\n        charAt,\n        currentChar,\n        currentPeek,\n        next,\n        peek,\n        reset,\n        resetPeek,\n        skipToPeek\n    };\n}\n\nconst EOF = undefined;\nconst DOT = '.';\nconst LITERAL_DELIMITER = \"'\";\nconst ERROR_DOMAIN$1 = 'tokenizer';\nfunction createTokenizer(source, options = {}) {\n    const location = options.location !== false;\n    const _scnr = createScanner(source);\n    const currentOffset = () => _scnr.index();\n    const currentPosition = () => createPosition(_scnr.line(), _scnr.column(), _scnr.index());\n    const _initLoc = currentPosition();\n    const _initOffset = currentOffset();\n    const _context = {\n        currentType: 13 /* TokenTypes.EOF */,\n        offset: _initOffset,\n        startLoc: _initLoc,\n        endLoc: _initLoc,\n        lastType: 13 /* TokenTypes.EOF */,\n        lastOffset: _initOffset,\n        lastStartLoc: _initLoc,\n        lastEndLoc: _initLoc,\n        braceNest: 0,\n        inLinked: false,\n        text: ''\n    };\n    const context = () => _context;\n    const { onError } = options;\n    function emitError(code, pos, offset, ...args) {\n        const ctx = context();\n        pos.column += offset;\n        pos.offset += offset;\n        if (onError) {\n            const loc = location ? createLocation(ctx.startLoc, pos) : null;\n            const err = createCompileError(code, loc, {\n                domain: ERROR_DOMAIN$1,\n                args\n            });\n            onError(err);\n        }\n    }\n    function getToken(context, type, value) {\n        context.endLoc = currentPosition();\n        context.currentType = type;\n        const token = { type };\n        if (location) {\n            token.loc = createLocation(context.startLoc, context.endLoc);\n        }\n        if (value != null) {\n            token.value = value;\n        }\n        return token;\n    }\n    const getEndToken = (context) => getToken(context, 13 /* TokenTypes.EOF */);\n    function eat(scnr, ch) {\n        if (scnr.currentChar() === ch) {\n            scnr.next();\n            return ch;\n        }\n        else {\n            emitError(CompileErrorCodes.EXPECTED_TOKEN, currentPosition(), 0, ch);\n            return '';\n        }\n    }\n    function peekSpaces(scnr) {\n        let buf = '';\n        while (scnr.currentPeek() === CHAR_SP || scnr.currentPeek() === CHAR_LF) {\n            buf += scnr.currentPeek();\n            scnr.peek();\n        }\n        return buf;\n    }\n    function skipSpaces(scnr) {\n        const buf = peekSpaces(scnr);\n        scnr.skipToPeek();\n        return buf;\n    }\n    function isIdentifierStart(ch) {\n        if (ch === EOF) {\n            return false;\n        }\n        const cc = ch.charCodeAt(0);\n        return ((cc >= 97 && cc <= 122) || // a-z\n            (cc >= 65 && cc <= 90) || // A-Z\n            cc === 95 // _\n        );\n    }\n    function isNumberStart(ch) {\n        if (ch === EOF) {\n            return false;\n        }\n        const cc = ch.charCodeAt(0);\n        return cc >= 48 && cc <= 57; // 0-9\n    }\n    function isNamedIdentifierStart(scnr, context) {\n        const { currentType } = context;\n        if (currentType !== 2 /* TokenTypes.BraceLeft */) {\n            return false;\n        }\n        peekSpaces(scnr);\n        const ret = isIdentifierStart(scnr.currentPeek());\n        scnr.resetPeek();\n        return ret;\n    }\n    function isListIdentifierStart(scnr, context) {\n        const { currentType } = context;\n        if (currentType !== 2 /* TokenTypes.BraceLeft */) {\n            return false;\n        }\n        peekSpaces(scnr);\n        const ch = scnr.currentPeek() === '-' ? scnr.peek() : scnr.currentPeek();\n        const ret = isNumberStart(ch);\n        scnr.resetPeek();\n        return ret;\n    }\n    function isLiteralStart(scnr, context) {\n        const { currentType } = context;\n        if (currentType !== 2 /* TokenTypes.BraceLeft */) {\n            return false;\n        }\n        peekSpaces(scnr);\n        const ret = scnr.currentPeek() === LITERAL_DELIMITER;\n        scnr.resetPeek();\n        return ret;\n    }\n    function isLinkedDotStart(scnr, context) {\n        const { currentType } = context;\n        if (currentType !== 7 /* TokenTypes.LinkedAlias */) {\n            return false;\n        }\n        peekSpaces(scnr);\n        const ret = scnr.currentPeek() === \".\" /* TokenChars.LinkedDot */;\n        scnr.resetPeek();\n        return ret;\n    }\n    function isLinkedModifierStart(scnr, context) {\n        const { currentType } = context;\n        if (currentType !== 8 /* TokenTypes.LinkedDot */) {\n            return false;\n        }\n        peekSpaces(scnr);\n        const ret = isIdentifierStart(scnr.currentPeek());\n        scnr.resetPeek();\n        return ret;\n    }\n    function isLinkedDelimiterStart(scnr, context) {\n        const { currentType } = context;\n        if (!(currentType === 7 /* TokenTypes.LinkedAlias */ ||\n            currentType === 11 /* TokenTypes.LinkedModifier */)) {\n            return false;\n        }\n        peekSpaces(scnr);\n        const ret = scnr.currentPeek() === \":\" /* TokenChars.LinkedDelimiter */;\n        scnr.resetPeek();\n        return ret;\n    }\n    function isLinkedReferStart(scnr, context) {\n        const { currentType } = context;\n        if (currentType !== 9 /* TokenTypes.LinkedDelimiter */) {\n            return false;\n        }\n        const fn = () => {\n            const ch = scnr.currentPeek();\n            if (ch === \"{\" /* TokenChars.BraceLeft */) {\n                return isIdentifierStart(scnr.peek());\n            }\n            else if (ch === \"@\" /* TokenChars.LinkedAlias */ ||\n                ch === \"|\" /* TokenChars.Pipe */ ||\n                ch === \":\" /* TokenChars.LinkedDelimiter */ ||\n                ch === \".\" /* TokenChars.LinkedDot */ ||\n                ch === CHAR_SP ||\n                !ch) {\n                return false;\n            }\n            else if (ch === CHAR_LF) {\n                scnr.peek();\n                return fn();\n            }\n            else {\n                // other characters\n                return isTextStart(scnr, false);\n            }\n        };\n        const ret = fn();\n        scnr.resetPeek();\n        return ret;\n    }\n    function isPluralStart(scnr) {\n        peekSpaces(scnr);\n        const ret = scnr.currentPeek() === \"|\" /* TokenChars.Pipe */;\n        scnr.resetPeek();\n        return ret;\n    }\n    function isTextStart(scnr, reset = true) {\n        const fn = (hasSpace = false, prev = '') => {\n            const ch = scnr.currentPeek();\n            if (ch === \"{\" /* TokenChars.BraceLeft */) {\n                return hasSpace;\n            }\n            else if (ch === \"@\" /* TokenChars.LinkedAlias */ || !ch) {\n                return hasSpace;\n            }\n            else if (ch === \"|\" /* TokenChars.Pipe */) {\n                return !(prev === CHAR_SP || prev === CHAR_LF);\n            }\n            else if (ch === CHAR_SP) {\n                scnr.peek();\n                return fn(true, CHAR_SP);\n            }\n            else if (ch === CHAR_LF) {\n                scnr.peek();\n                return fn(true, CHAR_LF);\n            }\n            else {\n                return true;\n            }\n        };\n        const ret = fn();\n        reset && scnr.resetPeek();\n        return ret;\n    }\n    function takeChar(scnr, fn) {\n        const ch = scnr.currentChar();\n        if (ch === EOF) {\n            return EOF;\n        }\n        if (fn(ch)) {\n            scnr.next();\n            return ch;\n        }\n        return null;\n    }\n    function isIdentifier(ch) {\n        const cc = ch.charCodeAt(0);\n        return ((cc >= 97 && cc <= 122) || // a-z\n            (cc >= 65 && cc <= 90) || // A-Z\n            (cc >= 48 && cc <= 57) || // 0-9\n            cc === 95 || // _\n            cc === 36 // $\n        );\n    }\n    function takeIdentifierChar(scnr) {\n        return takeChar(scnr, isIdentifier);\n    }\n    function isNamedIdentifier(ch) {\n        const cc = ch.charCodeAt(0);\n        return ((cc >= 97 && cc <= 122) || // a-z\n            (cc >= 65 && cc <= 90) || // A-Z\n            (cc >= 48 && cc <= 57) || // 0-9\n            cc === 95 || // _\n            cc === 36 || // $\n            cc === 45 // -\n        );\n    }\n    function takeNamedIdentifierChar(scnr) {\n        return takeChar(scnr, isNamedIdentifier);\n    }\n    function isDigit(ch) {\n        const cc = ch.charCodeAt(0);\n        return cc >= 48 && cc <= 57; // 0-9\n    }\n    function takeDigit(scnr) {\n        return takeChar(scnr, isDigit);\n    }\n    function isHexDigit(ch) {\n        const cc = ch.charCodeAt(0);\n        return ((cc >= 48 && cc <= 57) || // 0-9\n            (cc >= 65 && cc <= 70) || // A-F\n            (cc >= 97 && cc <= 102)); // a-f\n    }\n    function takeHexDigit(scnr) {\n        return takeChar(scnr, isHexDigit);\n    }\n    function getDigits(scnr) {\n        let ch = '';\n        let num = '';\n        while ((ch = takeDigit(scnr))) {\n            num += ch;\n        }\n        return num;\n    }\n    function readText(scnr) {\n        let buf = '';\n        while (true) {\n            const ch = scnr.currentChar();\n            if (ch === \"{\" /* TokenChars.BraceLeft */ ||\n                ch === \"}\" /* TokenChars.BraceRight */ ||\n                ch === \"@\" /* TokenChars.LinkedAlias */ ||\n                ch === \"|\" /* TokenChars.Pipe */ ||\n                !ch) {\n                break;\n            }\n            else if (ch === CHAR_SP || ch === CHAR_LF) {\n                if (isTextStart(scnr)) {\n                    buf += ch;\n                    scnr.next();\n                }\n                else if (isPluralStart(scnr)) {\n                    break;\n                }\n                else {\n                    buf += ch;\n                    scnr.next();\n                }\n            }\n            else {\n                buf += ch;\n                scnr.next();\n            }\n        }\n        return buf;\n    }\n    function readNamedIdentifier(scnr) {\n        skipSpaces(scnr);\n        let ch = '';\n        let name = '';\n        while ((ch = takeNamedIdentifierChar(scnr))) {\n            name += ch;\n        }\n        if (scnr.currentChar() === EOF) {\n            emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);\n        }\n        return name;\n    }\n    function readListIdentifier(scnr) {\n        skipSpaces(scnr);\n        let value = '';\n        if (scnr.currentChar() === '-') {\n            scnr.next();\n            value += `-${getDigits(scnr)}`;\n        }\n        else {\n            value += getDigits(scnr);\n        }\n        if (scnr.currentChar() === EOF) {\n            emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);\n        }\n        return value;\n    }\n    function isLiteral(ch) {\n        return ch !== LITERAL_DELIMITER && ch !== CHAR_LF;\n    }\n    function readLiteral(scnr) {\n        skipSpaces(scnr);\n        // eslint-disable-next-line no-useless-escape\n        eat(scnr, `\\'`);\n        let ch = '';\n        let literal = '';\n        while ((ch = takeChar(scnr, isLiteral))) {\n            if (ch === '\\\\') {\n                literal += readEscapeSequence(scnr);\n            }\n            else {\n                literal += ch;\n            }\n        }\n        const current = scnr.currentChar();\n        if (current === CHAR_LF || current === EOF) {\n            emitError(CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER, currentPosition(), 0);\n            // TODO: Is it correct really?\n            if (current === CHAR_LF) {\n                scnr.next();\n                // eslint-disable-next-line no-useless-escape\n                eat(scnr, `\\'`);\n            }\n            return literal;\n        }\n        // eslint-disable-next-line no-useless-escape\n        eat(scnr, `\\'`);\n        return literal;\n    }\n    function readEscapeSequence(scnr) {\n        const ch = scnr.currentChar();\n        switch (ch) {\n            case '\\\\':\n            case `\\'`: // eslint-disable-line no-useless-escape\n                scnr.next();\n                return `\\\\${ch}`;\n            case 'u':\n                return readUnicodeEscapeSequence(scnr, ch, 4);\n            case 'U':\n                return readUnicodeEscapeSequence(scnr, ch, 6);\n            default:\n                emitError(CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE, currentPosition(), 0, ch);\n                return '';\n        }\n    }\n    function readUnicodeEscapeSequence(scnr, unicode, digits) {\n        eat(scnr, unicode);\n        let sequence = '';\n        for (let i = 0; i < digits; i++) {\n            const ch = takeHexDigit(scnr);\n            if (!ch) {\n                emitError(CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE, currentPosition(), 0, `\\\\${unicode}${sequence}${scnr.currentChar()}`);\n                break;\n            }\n            sequence += ch;\n        }\n        return `\\\\${unicode}${sequence}`;\n    }\n    function isInvalidIdentifier(ch) {\n        return (ch !== \"{\" /* TokenChars.BraceLeft */ &&\n            ch !== \"}\" /* TokenChars.BraceRight */ &&\n            ch !== CHAR_SP &&\n            ch !== CHAR_LF);\n    }\n    function readInvalidIdentifier(scnr) {\n        skipSpaces(scnr);\n        let ch = '';\n        let identifiers = '';\n        while ((ch = takeChar(scnr, isInvalidIdentifier))) {\n            identifiers += ch;\n        }\n        return identifiers;\n    }\n    function readLinkedModifier(scnr) {\n        let ch = '';\n        let name = '';\n        while ((ch = takeIdentifierChar(scnr))) {\n            name += ch;\n        }\n        return name;\n    }\n    function readLinkedRefer(scnr) {\n        const fn = (buf) => {\n            const ch = scnr.currentChar();\n            if (ch === \"{\" /* TokenChars.BraceLeft */ ||\n                ch === \"@\" /* TokenChars.LinkedAlias */ ||\n                ch === \"|\" /* TokenChars.Pipe */ ||\n                ch === \"(\" /* TokenChars.ParenLeft */ ||\n                ch === \")\" /* TokenChars.ParenRight */ ||\n                !ch) {\n                return buf;\n            }\n            else if (ch === CHAR_SP) {\n                return buf;\n            }\n            else if (ch === CHAR_LF || ch === DOT) {\n                buf += ch;\n                scnr.next();\n                return fn(buf);\n            }\n            else {\n                buf += ch;\n                scnr.next();\n                return fn(buf);\n            }\n        };\n        return fn('');\n    }\n    function readPlural(scnr) {\n        skipSpaces(scnr);\n        const plural = eat(scnr, \"|\" /* TokenChars.Pipe */);\n        skipSpaces(scnr);\n        return plural;\n    }\n    // TODO: We need refactoring of token parsing ...\n    function readTokenInPlaceholder(scnr, context) {\n        let token = null;\n        const ch = scnr.currentChar();\n        switch (ch) {\n            case \"{\" /* TokenChars.BraceLeft */:\n                if (context.braceNest >= 1) {\n                    emitError(CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER, currentPosition(), 0);\n                }\n                scnr.next();\n                token = getToken(context, 2 /* TokenTypes.BraceLeft */, \"{\" /* TokenChars.BraceLeft */);\n                skipSpaces(scnr);\n                context.braceNest++;\n                return token;\n            case \"}\" /* TokenChars.BraceRight */:\n                if (context.braceNest > 0 &&\n                    context.currentType === 2 /* TokenTypes.BraceLeft */) {\n                    emitError(CompileErrorCodes.EMPTY_PLACEHOLDER, currentPosition(), 0);\n                }\n                scnr.next();\n                token = getToken(context, 3 /* TokenTypes.BraceRight */, \"}\" /* TokenChars.BraceRight */);\n                context.braceNest--;\n                context.braceNest > 0 && skipSpaces(scnr);\n                if (context.inLinked && context.braceNest === 0) {\n                    context.inLinked = false;\n                }\n                return token;\n            case \"@\" /* TokenChars.LinkedAlias */:\n                if (context.braceNest > 0) {\n                    emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);\n                }\n                token = readTokenInLinked(scnr, context) || getEndToken(context);\n                context.braceNest = 0;\n                return token;\n            default: {\n                let validNamedIdentifier = true;\n                let validListIdentifier = true;\n                let validLiteral = true;\n                if (isPluralStart(scnr)) {\n                    if (context.braceNest > 0) {\n                        emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);\n                    }\n                    token = getToken(context, 1 /* TokenTypes.Pipe */, readPlural(scnr));\n                    // reset\n                    context.braceNest = 0;\n                    context.inLinked = false;\n                    return token;\n                }\n                if (context.braceNest > 0 &&\n                    (context.currentType === 4 /* TokenTypes.Named */ ||\n                        context.currentType === 5 /* TokenTypes.List */ ||\n                        context.currentType === 6 /* TokenTypes.Literal */)) {\n                    emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);\n                    context.braceNest = 0;\n                    return readToken(scnr, context);\n                }\n                if ((validNamedIdentifier = isNamedIdentifierStart(scnr, context))) {\n                    token = getToken(context, 4 /* TokenTypes.Named */, readNamedIdentifier(scnr));\n                    skipSpaces(scnr);\n                    return token;\n                }\n                if ((validListIdentifier = isListIdentifierStart(scnr, context))) {\n                    token = getToken(context, 5 /* TokenTypes.List */, readListIdentifier(scnr));\n                    skipSpaces(scnr);\n                    return token;\n                }\n                if ((validLiteral = isLiteralStart(scnr, context))) {\n                    token = getToken(context, 6 /* TokenTypes.Literal */, readLiteral(scnr));\n                    skipSpaces(scnr);\n                    return token;\n                }\n                if (!validNamedIdentifier && !validListIdentifier && !validLiteral) {\n                    // TODO: we should be re-designed invalid cases, when we will extend message syntax near the future ...\n                    token = getToken(context, 12 /* TokenTypes.InvalidPlace */, readInvalidIdentifier(scnr));\n                    emitError(CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER, currentPosition(), 0, token.value);\n                    skipSpaces(scnr);\n                    return token;\n                }\n                break;\n            }\n        }\n        return token;\n    }\n    // TODO: We need refactoring of token parsing ...\n    function readTokenInLinked(scnr, context) {\n        const { currentType } = context;\n        let token = null;\n        const ch = scnr.currentChar();\n        if ((currentType === 7 /* TokenTypes.LinkedAlias */ ||\n            currentType === 8 /* TokenTypes.LinkedDot */ ||\n            currentType === 11 /* TokenTypes.LinkedModifier */ ||\n            currentType === 9 /* TokenTypes.LinkedDelimiter */) &&\n            (ch === CHAR_LF || ch === CHAR_SP)) {\n            emitError(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);\n        }\n        switch (ch) {\n            case \"@\" /* TokenChars.LinkedAlias */:\n                scnr.next();\n                token = getToken(context, 7 /* TokenTypes.LinkedAlias */, \"@\" /* TokenChars.LinkedAlias */);\n                context.inLinked = true;\n                return token;\n            case \".\" /* TokenChars.LinkedDot */:\n                skipSpaces(scnr);\n                scnr.next();\n                return getToken(context, 8 /* TokenTypes.LinkedDot */, \".\" /* TokenChars.LinkedDot */);\n            case \":\" /* TokenChars.LinkedDelimiter */:\n                skipSpaces(scnr);\n                scnr.next();\n                return getToken(context, 9 /* TokenTypes.LinkedDelimiter */, \":\" /* TokenChars.LinkedDelimiter */);\n            default:\n                if (isPluralStart(scnr)) {\n                    token = getToken(context, 1 /* TokenTypes.Pipe */, readPlural(scnr));\n                    // reset\n                    context.braceNest = 0;\n                    context.inLinked = false;\n                    return token;\n                }\n                if (isLinkedDotStart(scnr, context) ||\n                    isLinkedDelimiterStart(scnr, context)) {\n                    skipSpaces(scnr);\n                    return readTokenInLinked(scnr, context);\n                }\n                if (isLinkedModifierStart(scnr, context)) {\n                    skipSpaces(scnr);\n                    return getToken(context, 11 /* TokenTypes.LinkedModifier */, readLinkedModifier(scnr));\n                }\n                if (isLinkedReferStart(scnr, context)) {\n                    skipSpaces(scnr);\n                    if (ch === \"{\" /* TokenChars.BraceLeft */) {\n                        // scan the placeholder\n                        return readTokenInPlaceholder(scnr, context) || token;\n                    }\n                    else {\n                        return getToken(context, 10 /* TokenTypes.LinkedKey */, readLinkedRefer(scnr));\n                    }\n                }\n                if (currentType === 7 /* TokenTypes.LinkedAlias */) {\n                    emitError(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);\n                }\n                context.braceNest = 0;\n                context.inLinked = false;\n                return readToken(scnr, context);\n        }\n    }\n    // TODO: We need refactoring of token parsing ...\n    function readToken(scnr, context) {\n        let token = { type: 13 /* TokenTypes.EOF */ };\n        if (context.braceNest > 0) {\n            return readTokenInPlaceholder(scnr, context) || getEndToken(context);\n        }\n        if (context.inLinked) {\n            return readTokenInLinked(scnr, context) || getEndToken(context);\n        }\n        const ch = scnr.currentChar();\n        switch (ch) {\n            case \"{\" /* TokenChars.BraceLeft */:\n                return readTokenInPlaceholder(scnr, context) || getEndToken(context);\n            case \"}\" /* TokenChars.BraceRight */:\n                emitError(CompileErrorCodes.UNBALANCED_CLOSING_BRACE, currentPosition(), 0);\n                scnr.next();\n                return getToken(context, 3 /* TokenTypes.BraceRight */, \"}\" /* TokenChars.BraceRight */);\n            case \"@\" /* TokenChars.LinkedAlias */:\n                return readTokenInLinked(scnr, context) || getEndToken(context);\n            default: {\n                if (isPluralStart(scnr)) {\n                    token = getToken(context, 1 /* TokenTypes.Pipe */, readPlural(scnr));\n                    // reset\n                    context.braceNest = 0;\n                    context.inLinked = false;\n                    return token;\n                }\n                if (isTextStart(scnr)) {\n                    return getToken(context, 0 /* TokenTypes.Text */, readText(scnr));\n                }\n                break;\n            }\n        }\n        return token;\n    }\n    function nextToken() {\n        const { currentType, offset, startLoc, endLoc } = _context;\n        _context.lastType = currentType;\n        _context.lastOffset = offset;\n        _context.lastStartLoc = startLoc;\n        _context.lastEndLoc = endLoc;\n        _context.offset = currentOffset();\n        _context.startLoc = currentPosition();\n        if (_scnr.currentChar() === EOF) {\n            return getToken(_context, 13 /* TokenTypes.EOF */);\n        }\n        return readToken(_scnr, _context);\n    }\n    return {\n        nextToken,\n        currentOffset,\n        currentPosition,\n        context\n    };\n}\n\nconst ERROR_DOMAIN = 'parser';\n// Backslash backslash, backslash quote, uHHHH, UHHHHHH.\nconst KNOWN_ESCAPES = /(?:\\\\\\\\|\\\\'|\\\\u([0-9a-fA-F]{4})|\\\\U([0-9a-fA-F]{6}))/g;\nfunction fromEscapeSequence(match, codePoint4, codePoint6) {\n    switch (match) {\n        case `\\\\\\\\`:\n            return `\\\\`;\n        // eslint-disable-next-line no-useless-escape\n        case `\\\\\\'`:\n            // eslint-disable-next-line no-useless-escape\n            return `\\'`;\n        default: {\n            const codePoint = parseInt(codePoint4 || codePoint6, 16);\n            if (codePoint <= 0xd7ff || codePoint >= 0xe000) {\n                return String.fromCodePoint(codePoint);\n            }\n            // invalid ...\n            // Replace them with U+FFFD REPLACEMENT CHARACTER.\n            return '�';\n        }\n    }\n}\nfunction createParser(options = {}) {\n    const location = options.location !== false;\n    const { onError } = options;\n    function emitError(tokenzer, code, start, offset, ...args) {\n        const end = tokenzer.currentPosition();\n        end.offset += offset;\n        end.column += offset;\n        if (onError) {\n            const loc = location ? createLocation(start, end) : null;\n            const err = createCompileError(code, loc, {\n                domain: ERROR_DOMAIN,\n                args\n            });\n            onError(err);\n        }\n    }\n    function startNode(type, offset, loc) {\n        const node = { type };\n        if (location) {\n            node.start = offset;\n            node.end = offset;\n            node.loc = { start: loc, end: loc };\n        }\n        return node;\n    }\n    function endNode(node, offset, pos, type) {\n        if (location) {\n            node.end = offset;\n            if (node.loc) {\n                node.loc.end = pos;\n            }\n        }\n    }\n    function parseText(tokenizer, value) {\n        const context = tokenizer.context();\n        const node = startNode(3 /* NodeTypes.Text */, context.offset, context.startLoc);\n        node.value = value;\n        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n        return node;\n    }\n    function parseList(tokenizer, index) {\n        const context = tokenizer.context();\n        const { lastOffset: offset, lastStartLoc: loc } = context; // get brace left loc\n        const node = startNode(5 /* NodeTypes.List */, offset, loc);\n        node.index = parseInt(index, 10);\n        tokenizer.nextToken(); // skip brach right\n        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n        return node;\n    }\n    function parseNamed(tokenizer, key) {\n        const context = tokenizer.context();\n        const { lastOffset: offset, lastStartLoc: loc } = context; // get brace left loc\n        const node = startNode(4 /* NodeTypes.Named */, offset, loc);\n        node.key = key;\n        tokenizer.nextToken(); // skip brach right\n        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n        return node;\n    }\n    function parseLiteral(tokenizer, value) {\n        const context = tokenizer.context();\n        const { lastOffset: offset, lastStartLoc: loc } = context; // get brace left loc\n        const node = startNode(9 /* NodeTypes.Literal */, offset, loc);\n        node.value = value.replace(KNOWN_ESCAPES, fromEscapeSequence);\n        tokenizer.nextToken(); // skip brach right\n        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n        return node;\n    }\n    function parseLinkedModifier(tokenizer) {\n        const token = tokenizer.nextToken();\n        const context = tokenizer.context();\n        const { lastOffset: offset, lastStartLoc: loc } = context; // get linked dot loc\n        const node = startNode(8 /* NodeTypes.LinkedModifier */, offset, loc);\n        if (token.type !== 11 /* TokenTypes.LinkedModifier */) {\n            // empty modifier\n            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER, context.lastStartLoc, 0);\n            node.value = '';\n            endNode(node, offset, loc);\n            return {\n                nextConsumeToken: token,\n                node\n            };\n        }\n        // check token\n        if (token.value == null) {\n            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n        }\n        node.value = token.value || '';\n        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n        return {\n            node\n        };\n    }\n    function parseLinkedKey(tokenizer, value) {\n        const context = tokenizer.context();\n        const node = startNode(7 /* NodeTypes.LinkedKey */, context.offset, context.startLoc);\n        node.value = value;\n        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n        return node;\n    }\n    function parseLinked(tokenizer) {\n        const context = tokenizer.context();\n        const linkedNode = startNode(6 /* NodeTypes.Linked */, context.offset, context.startLoc);\n        let token = tokenizer.nextToken();\n        if (token.type === 8 /* TokenTypes.LinkedDot */) {\n            const parsed = parseLinkedModifier(tokenizer);\n            linkedNode.modifier = parsed.node;\n            token = parsed.nextConsumeToken || tokenizer.nextToken();\n        }\n        // asset check token\n        if (token.type !== 9 /* TokenTypes.LinkedDelimiter */) {\n            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n        }\n        token = tokenizer.nextToken();\n        // skip brace left\n        if (token.type === 2 /* TokenTypes.BraceLeft */) {\n            token = tokenizer.nextToken();\n        }\n        switch (token.type) {\n            case 10 /* TokenTypes.LinkedKey */:\n                if (token.value == null) {\n                    emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n                }\n                linkedNode.key = parseLinkedKey(tokenizer, token.value || '');\n                break;\n            case 4 /* TokenTypes.Named */:\n                if (token.value == null) {\n                    emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n                }\n                linkedNode.key = parseNamed(tokenizer, token.value || '');\n                break;\n            case 5 /* TokenTypes.List */:\n                if (token.value == null) {\n                    emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n                }\n                linkedNode.key = parseList(tokenizer, token.value || '');\n                break;\n            case 6 /* TokenTypes.Literal */:\n                if (token.value == null) {\n                    emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n                }\n                linkedNode.key = parseLiteral(tokenizer, token.value || '');\n                break;\n            default: {\n                // empty key\n                emitError(tokenizer, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY, context.lastStartLoc, 0);\n                const nextContext = tokenizer.context();\n                const emptyLinkedKeyNode = startNode(7 /* NodeTypes.LinkedKey */, nextContext.offset, nextContext.startLoc);\n                emptyLinkedKeyNode.value = '';\n                endNode(emptyLinkedKeyNode, nextContext.offset, nextContext.startLoc);\n                linkedNode.key = emptyLinkedKeyNode;\n                endNode(linkedNode, nextContext.offset, nextContext.startLoc);\n                return {\n                    nextConsumeToken: token,\n                    node: linkedNode\n                };\n            }\n        }\n        endNode(linkedNode, tokenizer.currentOffset(), tokenizer.currentPosition());\n        return {\n            node: linkedNode\n        };\n    }\n    function parseMessage(tokenizer) {\n        const context = tokenizer.context();\n        const startOffset = context.currentType === 1 /* TokenTypes.Pipe */\n            ? tokenizer.currentOffset()\n            : context.offset;\n        const startLoc = context.currentType === 1 /* TokenTypes.Pipe */\n            ? context.endLoc\n            : context.startLoc;\n        const node = startNode(2 /* NodeTypes.Message */, startOffset, startLoc);\n        node.items = [];\n        let nextToken = null;\n        do {\n            const token = nextToken || tokenizer.nextToken();\n            nextToken = null;\n            switch (token.type) {\n                case 0 /* TokenTypes.Text */:\n                    if (token.value == null) {\n                        emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n                    }\n                    node.items.push(parseText(tokenizer, token.value || ''));\n                    break;\n                case 5 /* TokenTypes.List */:\n                    if (token.value == null) {\n                        emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n                    }\n                    node.items.push(parseList(tokenizer, token.value || ''));\n                    break;\n                case 4 /* TokenTypes.Named */:\n                    if (token.value == null) {\n                        emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n                    }\n                    node.items.push(parseNamed(tokenizer, token.value || ''));\n                    break;\n                case 6 /* TokenTypes.Literal */:\n                    if (token.value == null) {\n                        emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n                    }\n                    node.items.push(parseLiteral(tokenizer, token.value || ''));\n                    break;\n                case 7 /* TokenTypes.LinkedAlias */: {\n                    const parsed = parseLinked(tokenizer);\n                    node.items.push(parsed.node);\n                    nextToken = parsed.nextConsumeToken || null;\n                    break;\n                }\n            }\n        } while (context.currentType !== 13 /* TokenTypes.EOF */ &&\n            context.currentType !== 1 /* TokenTypes.Pipe */);\n        // adjust message node loc\n        const endOffset = context.currentType === 1 /* TokenTypes.Pipe */\n            ? context.lastOffset\n            : tokenizer.currentOffset();\n        const endLoc = context.currentType === 1 /* TokenTypes.Pipe */\n            ? context.lastEndLoc\n            : tokenizer.currentPosition();\n        endNode(node, endOffset, endLoc);\n        return node;\n    }\n    function parsePlural(tokenizer, offset, loc, msgNode) {\n        const context = tokenizer.context();\n        let hasEmptyMessage = msgNode.items.length === 0;\n        const node = startNode(1 /* NodeTypes.Plural */, offset, loc);\n        node.cases = [];\n        node.cases.push(msgNode);\n        do {\n            const msg = parseMessage(tokenizer);\n            if (!hasEmptyMessage) {\n                hasEmptyMessage = msg.items.length === 0;\n            }\n            node.cases.push(msg);\n        } while (context.currentType !== 13 /* TokenTypes.EOF */);\n        if (hasEmptyMessage) {\n            emitError(tokenizer, CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL, loc, 0);\n        }\n        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n        return node;\n    }\n    function parseResource(tokenizer) {\n        const context = tokenizer.context();\n        const { offset, startLoc } = context;\n        const msgNode = parseMessage(tokenizer);\n        if (context.currentType === 13 /* TokenTypes.EOF */) {\n            return msgNode;\n        }\n        else {\n            return parsePlural(tokenizer, offset, startLoc, msgNode);\n        }\n    }\n    function parse(source) {\n        const tokenizer = createTokenizer(source, assign({}, options));\n        const context = tokenizer.context();\n        const node = startNode(0 /* NodeTypes.Resource */, context.offset, context.startLoc);\n        if (location && node.loc) {\n            node.loc.source = source;\n        }\n        node.body = parseResource(tokenizer);\n        if (options.onCacheKey) {\n            node.cacheKey = options.onCacheKey(source);\n        }\n        // assert whether achieved to EOF\n        if (context.currentType !== 13 /* TokenTypes.EOF */) {\n            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, source[context.offset] || '');\n        }\n        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n        return node;\n    }\n    return { parse };\n}\nfunction getTokenCaption(token) {\n    if (token.type === 13 /* TokenTypes.EOF */) {\n        return 'EOF';\n    }\n    const name = (token.value || '').replace(/\\r?\\n/gu, '\\\\n');\n    return name.length > 10 ? name.slice(0, 9) + '…' : name;\n}\n\nfunction createTransformer(ast, options = {} // eslint-disable-line\n) {\n    const _context = {\n        ast,\n        helpers: new Set()\n    };\n    const context = () => _context;\n    const helper = (name) => {\n        _context.helpers.add(name);\n        return name;\n    };\n    return { context, helper };\n}\nfunction traverseNodes(nodes, transformer) {\n    for (let i = 0; i < nodes.length; i++) {\n        traverseNode(nodes[i], transformer);\n    }\n}\nfunction traverseNode(node, transformer) {\n    // TODO: if we need pre-hook of transform, should be implemented to here\n    switch (node.type) {\n        case 1 /* NodeTypes.Plural */:\n            traverseNodes(node.cases, transformer);\n            transformer.helper(\"plural\" /* HelperNameMap.PLURAL */);\n            break;\n        case 2 /* NodeTypes.Message */:\n            traverseNodes(node.items, transformer);\n            break;\n        case 6 /* NodeTypes.Linked */: {\n            const linked = node;\n            traverseNode(linked.key, transformer);\n            transformer.helper(\"linked\" /* HelperNameMap.LINKED */);\n            transformer.helper(\"type\" /* HelperNameMap.TYPE */);\n            break;\n        }\n        case 5 /* NodeTypes.List */:\n            transformer.helper(\"interpolate\" /* HelperNameMap.INTERPOLATE */);\n            transformer.helper(\"list\" /* HelperNameMap.LIST */);\n            break;\n        case 4 /* NodeTypes.Named */:\n            transformer.helper(\"interpolate\" /* HelperNameMap.INTERPOLATE */);\n            transformer.helper(\"named\" /* HelperNameMap.NAMED */);\n            break;\n    }\n    // TODO: if we need post-hook of transform, should be implemented to here\n}\n// transform AST\nfunction transform(ast, options = {} // eslint-disable-line\n) {\n    const transformer = createTransformer(ast);\n    transformer.helper(\"normalize\" /* HelperNameMap.NORMALIZE */);\n    // traverse\n    ast.body && traverseNode(ast.body, transformer);\n    // set meta information\n    const context = transformer.context();\n    ast.helpers = Array.from(context.helpers);\n}\n\nfunction baseCompile(source, options = {}) {\n    const assignedOptions = assign({}, options);\n    const jit = !!assignedOptions.jit;\n    const enableMangle = !!assignedOptions.mangle;\n    const enableOptimize = assignedOptions.optimize == null ? true : assignedOptions.optimize;\n    // parse source codes\n    const parser = createParser(assignedOptions);\n    const ast = parser.parse(source);\n    // TODO:\n    // With the introduction of Jit compilation, code generation is no longer necessary. This function may no longer be needed since tree-shaking is not possible.\n    if (!jit) {\n        // transform ASTs\n        transform(ast, assignedOptions);\n        // generate javascript codes\n        return generate(ast, assignedOptions);\n    }\n    else {\n        // optimize ASTs\n        enableOptimize && optimize(ast);\n        // minimize ASTs\n        enableMangle && mangle(ast);\n        // In JIT mode, no ast transform, no code generation.\n        return { ast, code: '' };\n    }\n}\n\n// eslint-disable-next-line no-useless-escape\nconst RE_HTML_TAG = /<\\/?[\\w\\s=\"/.':;#-\\/]+>/;\nconst detectHtmlTag = (source) => RE_HTML_TAG.test(source);\n\nexport { COMPILE_ERROR_CODES_EXTEND_POINT, CompileErrorCodes, ERROR_DOMAIN, LOCATION_STUB, baseCompile, createCompileError, createLocation, createParser, createPosition, defaultOnError, detectHtmlTag, errorMessages, mangle, optimize };\n"],"mappings":";;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA,SAASA,MAAM,EAAEC,QAAQ,EAAEC,IAAI,EAAEC,MAAM,QAAQ,iBAAiB;AAEhE,MAAMC,aAAa,GAAG;EAClBC,KAAK,EAAE;IAAEC,IAAI,EAAE,CAAC;IAAEC,MAAM,EAAE,CAAC;IAAEC,MAAM,EAAE;EAAE,CAAC;EACxCC,GAAG,EAAE;IAAEH,IAAI,EAAE,CAAC;IAAEC,MAAM,EAAE,CAAC;IAAEC,MAAM,EAAE;EAAE;AACzC,CAAC;AACD,SAASE,cAAcA,CAACJ,IAAI,EAAEC,MAAM,EAAEC,MAAM,EAAE;EAC1C,OAAO;IAAEF,IAAI;IAAEC,MAAM;IAAEC;EAAO,CAAC;AACnC;AACA,SAASG,cAAcA,CAACN,KAAK,EAAEI,GAAG,EAAEG,MAAM,EAAE;EACxC,MAAMC,GAAG,GAAG;IAAER,KAAK;IAAEI;EAAI,CAAC;EAC1B,IAAIG,MAAM,IAAI,IAAI,EAAE;IAChBC,GAAG,CAACD,MAAM,GAAGA,MAAM;EACvB;EACA,OAAOC,GAAG;AACd;AAEA,MAAMC,iBAAiB,GAAG;EACtB;EACAC,cAAc,EAAE,CAAC;EACjBC,4BAA4B,EAAE,CAAC;EAC/BC,wCAAwC,EAAE,CAAC;EAC3CC,uBAAuB,EAAE,CAAC;EAC1BC,+BAA+B,EAAE,CAAC;EAClCC,wBAAwB,EAAE,CAAC;EAC3BC,0BAA0B,EAAE,CAAC;EAC7BC,iBAAiB,EAAE,CAAC;EACpBC,0BAA0B,EAAE,CAAC;EAC7BC,qBAAqB,EAAE,EAAE;EACzB;EACAC,4BAA4B,EAAE,EAAE;EAChCC,gCAAgC,EAAE,EAAE;EACpCC,2BAA2B,EAAE,EAAE;EAC/BC,2BAA2B,EAAE,EAAE;EAC/B;EACAC,2BAA2B,EAAE,EAAE;EAC/B;EACAC,4BAA4B,EAAE;AAClC,CAAC;AACD;AACA;AACA;AACA,MAAMC,gCAAgC,GAAG,EAAE;AAC3C;AACA,MAAMC,aAAa,GAAG;EAClB;EACA,CAAClB,iBAAiB,CAACC,cAAc,GAAG,uBAAuB;EAC3D,CAACD,iBAAiB,CAACE,4BAA4B,GAAG,qCAAqC;EACvF,CAACF,iBAAiB,CAACG,wCAAwC,GAAG,0CAA0C;EACxG,CAACH,iBAAiB,CAACI,uBAAuB,GAAG,gCAAgC;EAC7E,CAACJ,iBAAiB,CAACK,+BAA+B,GAAG,sCAAsC;EAC3F,CAACL,iBAAiB,CAACM,wBAAwB,GAAG,0BAA0B;EACxE,CAACN,iBAAiB,CAACO,0BAA0B,GAAG,4BAA4B;EAC5E,CAACP,iBAAiB,CAACQ,iBAAiB,GAAG,mBAAmB;EAC1D,CAACR,iBAAiB,CAACS,0BAA0B,GAAG,8BAA8B;EAC9E,CAACT,iBAAiB,CAACU,qBAAqB,GAAG,uBAAuB;EAClE;EACA,CAACV,iBAAiB,CAACW,4BAA4B,GAAG,2BAA2B;EAC7E,CAACX,iBAAiB,CAACY,gCAAgC,GAAG,kCAAkC;EACxF,CAACZ,iBAAiB,CAACa,2BAA2B,GAAG,6BAA6B;EAC9E,CAACb,iBAAiB,CAACc,2BAA2B,GAAG,6CAA6C;EAC9F;EACA,CAACd,iBAAiB,CAACe,2BAA2B,GAAG,oCAAoC;EACrF;EACA,CAACf,iBAAiB,CAACgB,4BAA4B,GAAG;AACtD,CAAC;AACD,SAASG,kBAAkBA,CAACC,IAAI,EAAErB,GAAG,EAAEsB,OAAO,GAAG,CAAC,CAAC,EAAE;EACjD,MAAM;IAAEC,MAAM;IAAEC,QAAQ;IAAEC;EAAK,CAAC,GAAGH,OAAO;EAC1C,MAAMI,GAAG,GAAIC,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,GAC5C1C,MAAM,CAAC,CAACqC,QAAQ,IAAIL,aAAa,EAAEE,IAAI,CAAC,IAAI,EAAE,EAAE,IAAII,IAAI,IAAI,EAAE,CAAC,CAAC,GAChEJ,IAAI;EACV,MAAMS,KAAK,GAAG,IAAIC,WAAW,CAACC,MAAM,CAACN,GAAG,CAAC,CAAC;EAC1CI,KAAK,CAACT,IAAI,GAAGA,IAAI;EACjB,IAAIrB,GAAG,EAAE;IACL8B,KAAK,CAACG,QAAQ,GAAGjC,GAAG;EACxB;EACA8B,KAAK,CAACP,MAAM,GAAGA,MAAM;EACrB,OAAOO,KAAK;AAChB;AACA;AACA,SAASI,cAAcA,CAACJ,KAAK,EAAE;EAC3B,MAAMA,KAAK;AACf;;AAEA;AACA;AACA,MAAMK,cAAc,GAAG,QAAQ;AAC/B,SAASC,mBAAmBA,CAACC,GAAG,EAAEf,OAAO,EAAE;EACvC,MAAM;IAAEgB,SAAS;IAAEC,QAAQ;IAAEC,aAAa;IAAEC,UAAU,EAAEC;EAAY,CAAC,GAAGpB,OAAO;EAC/E,MAAMW,QAAQ,GAAGX,OAAO,CAACW,QAAQ,KAAK,KAAK;EAC3C,MAAMU,QAAQ,GAAG;IACbJ,QAAQ;IACRlB,IAAI,EAAE,EAAE;IACR3B,MAAM,EAAE,CAAC;IACTD,IAAI,EAAE,CAAC;IACPE,MAAM,EAAE,CAAC;IACTiD,GAAG,EAAEC,SAAS;IACdL,aAAa;IACbC,UAAU,EAAEC,WAAW;IACvBI,WAAW,EAAE;EACjB,CAAC;EACD,IAAIb,QAAQ,IAAII,GAAG,CAACrC,GAAG,EAAE;IACrB2C,QAAQ,CAAC5C,MAAM,GAAGsC,GAAG,CAACrC,GAAG,CAACD,MAAM;EACpC;EACA,MAAMgD,OAAO,GAAGA,CAAA,KAAMJ,QAAQ;EAC9B,SAASK,IAAIA,CAAC3B,IAAI,EAAE4B,IAAI,EAAE;IACtBN,QAAQ,CAACtB,IAAI,IAAIA,IAAI;EACzB;EACA,SAAS6B,QAAQA,CAACC,CAAC,EAAEC,aAAa,GAAG,IAAI,EAAE;IACvC,MAAMC,cAAc,GAAGD,aAAa,GAAGZ,aAAa,GAAG,EAAE;IACzDQ,IAAI,CAACN,WAAW,GAAGW,cAAc,GAAG,IAAI,CAACC,MAAM,CAACH,CAAC,CAAC,GAAGE,cAAc,CAAC;EACxE;EACA,SAASE,MAAMA,CAACC,WAAW,GAAG,IAAI,EAAE;IAChC,MAAMC,KAAK,GAAG,EAAEd,QAAQ,CAACG,WAAW;IACpCU,WAAW,IAAIN,QAAQ,CAACO,KAAK,CAAC;EAClC;EACA,SAASC,QAAQA,CAACF,WAAW,GAAG,IAAI,EAAE;IAClC,MAAMC,KAAK,GAAG,EAAEd,QAAQ,CAACG,WAAW;IACpCU,WAAW,IAAIN,QAAQ,CAACO,KAAK,CAAC;EAClC;EACA,SAASE,OAAOA,CAAA,EAAG;IACfT,QAAQ,CAACP,QAAQ,CAACG,WAAW,CAAC;EAClC;EACA,MAAMc,MAAM,GAAIC,GAAG,IAAK,IAAIA,GAAG,EAAE;EACjC,MAAMpB,UAAU,GAAGA,CAAA,KAAME,QAAQ,CAACF,UAAU;EAC5C,OAAO;IACHM,OAAO;IACPC,IAAI;IACJO,MAAM;IACNG,QAAQ;IACRC,OAAO;IACPC,MAAM;IACNnB;EACJ,CAAC;AACL;AACA,SAASqB,kBAAkBA,CAACC,SAAS,EAAEd,IAAI,EAAE;EACzC,MAAM;IAAEW;EAAO,CAAC,GAAGG,SAAS;EAC5BA,SAAS,CAACf,IAAI,CAAC,GAAGY,MAAM,CAAC,QAAQ,CAAC,0BAA0B,CAAC,GAAG,CAAC;EACjEI,YAAY,CAACD,SAAS,EAAEd,IAAI,CAACY,GAAG,CAAC;EACjC,IAAIZ,IAAI,CAACgB,QAAQ,EAAE;IACfF,SAAS,CAACf,IAAI,CAAC,IAAI,CAAC;IACpBgB,YAAY,CAACD,SAAS,EAAEd,IAAI,CAACgB,QAAQ,CAAC;IACtCF,SAAS,CAACf,IAAI,CAAC,SAAS,CAAC;EAC7B,CAAC,MACI;IACDe,SAAS,CAACf,IAAI,CAAC,oBAAoB,CAAC;EACxC;EACAe,SAAS,CAACf,IAAI,CAAC,GAAG,CAAC;AACvB;AACA,SAASkB,mBAAmBA,CAACH,SAAS,EAAEd,IAAI,EAAE;EAC1C,MAAM;IAAEW,MAAM;IAAEnB;EAAW,CAAC,GAAGsB,SAAS;EACxCA,SAAS,CAACf,IAAI,CAAC,GAAGY,MAAM,CAAC,WAAW,CAAC,6BAA6B,CAAC,IAAI,CAAC;EACxEG,SAAS,CAACR,MAAM,CAACd,UAAU,CAAC,CAAC,CAAC;EAC9B,MAAM0B,MAAM,GAAGlB,IAAI,CAACmB,KAAK,CAACD,MAAM;EAChC,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,MAAM,EAAEE,CAAC,EAAE,EAAE;IAC7BL,YAAY,CAACD,SAAS,EAAEd,IAAI,CAACmB,KAAK,CAACC,CAAC,CAAC,CAAC;IACtC,IAAIA,CAAC,KAAKF,MAAM,GAAG,CAAC,EAAE;MAClB;IACJ;IACAJ,SAAS,CAACf,IAAI,CAAC,IAAI,CAAC;EACxB;EACAe,SAAS,CAACL,QAAQ,CAACjB,UAAU,CAAC,CAAC,CAAC;EAChCsB,SAAS,CAACf,IAAI,CAAC,IAAI,CAAC;AACxB;AACA,SAASsB,kBAAkBA,CAACP,SAAS,EAAEd,IAAI,EAAE;EACzC,MAAM;IAAEW,MAAM;IAAEnB;EAAW,CAAC,GAAGsB,SAAS;EACxC,IAAId,IAAI,CAACsB,KAAK,CAACJ,MAAM,GAAG,CAAC,EAAE;IACvBJ,SAAS,CAACf,IAAI,CAAC,GAAGY,MAAM,CAAC,QAAQ,CAAC,0BAA0B,CAAC,IAAI,CAAC;IAClEG,SAAS,CAACR,MAAM,CAACd,UAAU,CAAC,CAAC,CAAC;IAC9B,MAAM0B,MAAM,GAAGlB,IAAI,CAACsB,KAAK,CAACJ,MAAM;IAChC,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,MAAM,EAAEE,CAAC,EAAE,EAAE;MAC7BL,YAAY,CAACD,SAAS,EAAEd,IAAI,CAACsB,KAAK,CAACF,CAAC,CAAC,CAAC;MACtC,IAAIA,CAAC,KAAKF,MAAM,GAAG,CAAC,EAAE;QAClB;MACJ;MACAJ,SAAS,CAACf,IAAI,CAAC,IAAI,CAAC;IACxB;IACAe,SAAS,CAACL,QAAQ,CAACjB,UAAU,CAAC,CAAC,CAAC;IAChCsB,SAAS,CAACf,IAAI,CAAC,IAAI,CAAC;EACxB;AACJ;AACA,SAASwB,gBAAgBA,CAACT,SAAS,EAAEd,IAAI,EAAE;EACvC,IAAIA,IAAI,CAACwB,IAAI,EAAE;IACXT,YAAY,CAACD,SAAS,EAAEd,IAAI,CAACwB,IAAI,CAAC;EACtC,CAAC,MACI;IACDV,SAAS,CAACf,IAAI,CAAC,MAAM,CAAC;EAC1B;AACJ;AACA,SAASgB,YAAYA,CAACD,SAAS,EAAEd,IAAI,EAAE;EACnC,MAAM;IAAEW;EAAO,CAAC,GAAGG,SAAS;EAC5B,QAAQd,IAAI,CAACyB,IAAI;IACb,KAAK,CAAC,CAAC;MACHF,gBAAgB,CAACT,SAAS,EAAEd,IAAI,CAAC;MACjC;IACJ,KAAK,CAAC,CAAC;MACHqB,kBAAkB,CAACP,SAAS,EAAEd,IAAI,CAAC;MACnC;IACJ,KAAK,CAAC,CAAC;MACHiB,mBAAmB,CAACH,SAAS,EAAEd,IAAI,CAAC;MACpC;IACJ,KAAK,CAAC,CAAC;MACHa,kBAAkB,CAACC,SAAS,EAAEd,IAAI,CAAC;MACnC;IACJ,KAAK,CAAC,CAAC;MACHc,SAAS,CAACf,IAAI,CAAC2B,IAAI,CAACC,SAAS,CAAC3B,IAAI,CAAC4B,KAAK,CAAC,EAAE5B,IAAI,CAAC;MAChD;IACJ,KAAK,CAAC,CAAC;MACHc,SAAS,CAACf,IAAI,CAAC2B,IAAI,CAACC,SAAS,CAAC3B,IAAI,CAAC4B,KAAK,CAAC,EAAE5B,IAAI,CAAC;MAChD;IACJ,KAAK,CAAC,CAAC;MACHc,SAAS,CAACf,IAAI,CAAC,GAAGY,MAAM,CAAC,aAAa,CAAC,+BAA+B,CAAC,IAAIA,MAAM,CAAC,MAAM,CAAC,wBAAwB,CAAC,IAAIX,IAAI,CAAC6B,KAAK,IAAI,EAAE7B,IAAI,CAAC;MAC3I;IACJ,KAAK,CAAC,CAAC;MACHc,SAAS,CAACf,IAAI,CAAC,GAAGY,MAAM,CAAC,aAAa,CAAC,+BAA+B,CAAC,IAAIA,MAAM,CAAC,OAAO,CAAC,yBAAyB,CAAC,IAAIe,IAAI,CAACC,SAAS,CAAC3B,IAAI,CAACY,GAAG,CAAC,IAAI,EAAEZ,IAAI,CAAC;MAC3J;IACJ,KAAK,CAAC,CAAC;MACHc,SAAS,CAACf,IAAI,CAAC2B,IAAI,CAACC,SAAS,CAAC3B,IAAI,CAAC4B,KAAK,CAAC,EAAE5B,IAAI,CAAC;MAChD;IACJ,KAAK,CAAC,CAAC;MACHc,SAAS,CAACf,IAAI,CAAC2B,IAAI,CAACC,SAAS,CAAC3B,IAAI,CAAC4B,KAAK,CAAC,EAAE5B,IAAI,CAAC;MAChD;IACJ;MACI,IAAKtB,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAG;QACzC,MAAMT,kBAAkB,CAACnB,iBAAiB,CAACe,2BAA2B,EAAE,IAAI,EAAE;UAC1EO,MAAM,EAAEY,cAAc;UACtBV,IAAI,EAAE,CAACwB,IAAI,CAACyB,IAAI;QACpB,CAAC,CAAC;MACN;EACR;AACJ;AACA;AACA,MAAMK,QAAQ,GAAGA,CAAC1C,GAAG,EAAEf,OAAO,GAAG,CAAC,CAAC,KAAK;EACpC,MAAM0D,IAAI,GAAG5F,QAAQ,CAACkC,OAAO,CAAC0D,IAAI,CAAC,GAAG1D,OAAO,CAAC0D,IAAI,GAAG,QAAQ;EAC7D,MAAMzC,QAAQ,GAAGnD,QAAQ,CAACkC,OAAO,CAACiB,QAAQ,CAAC,GACrCjB,OAAO,CAACiB,QAAQ,GAChB,cAAc;EACpB,MAAMD,SAAS,GAAG,CAAC,CAAChB,OAAO,CAACgB,SAAS;EACrC;EACA,MAAME,aAAa,GAAGlB,OAAO,CAACkB,aAAa,IAAI,IAAI,GAC7ClB,OAAO,CAACkB,aAAa,GACrBwC,IAAI,KAAK,OAAO,GACZ,GAAG,GACH,IAAI;EACd,MAAMvC,UAAU,GAAGnB,OAAO,CAACmB,UAAU,GAAGnB,OAAO,CAACmB,UAAU,GAAGuC,IAAI,KAAK,OAAO;EAC7E,MAAMC,OAAO,GAAG5C,GAAG,CAAC4C,OAAO,IAAI,EAAE;EACjC,MAAMlB,SAAS,GAAG3B,mBAAmB,CAACC,GAAG,EAAE;IACvC2C,IAAI;IACJzC,QAAQ;IACRD,SAAS;IACTE,aAAa;IACbC;EACJ,CAAC,CAAC;EACFsB,SAAS,CAACf,IAAI,CAACgC,IAAI,KAAK,QAAQ,GAAG,0BAA0B,GAAG,YAAY,CAAC;EAC7EjB,SAAS,CAACR,MAAM,CAACd,UAAU,CAAC;EAC5B,IAAIwC,OAAO,CAACd,MAAM,GAAG,CAAC,EAAE;IACpBJ,SAAS,CAACf,IAAI,CAAC,WAAW3D,IAAI,CAAC4F,OAAO,CAACrC,GAAG,CAACsC,CAAC,IAAI,GAAGA,CAAC,MAAMA,CAAC,EAAE,CAAC,EAAE,IAAI,CAAC,UAAU,CAAC;IAChFnB,SAAS,CAACJ,OAAO,CAAC,CAAC;EACvB;EACAI,SAAS,CAACf,IAAI,CAAC,SAAS,CAAC;EACzBgB,YAAY,CAACD,SAAS,EAAE1B,GAAG,CAAC;EAC5B0B,SAAS,CAACL,QAAQ,CAACjB,UAAU,CAAC;EAC9BsB,SAAS,CAACf,IAAI,CAAC,GAAG,CAAC;EACnB,OAAOX,GAAG,CAAC4C,OAAO;EAClB,MAAM;IAAE5D,IAAI;IAAEuB;EAAI,CAAC,GAAGmB,SAAS,CAAChB,OAAO,CAAC,CAAC;EACzC,OAAO;IACHV,GAAG;IACHhB,IAAI;IACJuB,GAAG,EAAEA,GAAG,GAAGA,GAAG,CAACuC,MAAM,CAAC,CAAC,GAAGtC,SAAS,CAAC;EACxC,CAAC;AACL,CAAC;AAED,MAAMuC,cAAc,GAAG,UAAU;AACjC;AACA,SAASC,MAAMA,CAACpC,IAAI,EAAE;EAClBA,IAAI,CAACqC,CAAC,GAAGrC,IAAI,CAACyB,IAAI;EAClB,QAAQzB,IAAI,CAACyB,IAAI;IACb,KAAK,CAAC,CAAC;MAA0B;QAC7B,MAAMa,QAAQ,GAAGtC,IAAI;QACrBoC,MAAM,CAACE,QAAQ,CAACd,IAAI,CAAC;QACrBc,QAAQ,CAACC,CAAC,GAAGD,QAAQ,CAACd,IAAI;QAC1B,OAAOc,QAAQ,CAACd,IAAI;QACpB;MACJ;IACA,KAAK,CAAC,CAAC;MAAwB;QAC3B,MAAMgB,MAAM,GAAGxC,IAAI;QACnB,MAAMsB,KAAK,GAAGkB,MAAM,CAAClB,KAAK;QAC1B,KAAK,IAAIF,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGE,KAAK,CAACJ,MAAM,EAAEE,CAAC,EAAE,EAAE;UACnCgB,MAAM,CAACd,KAAK,CAACF,CAAC,CAAC,CAAC;QACpB;QACAoB,MAAM,CAACC,CAAC,GAAGnB,KAAK;QAChB,OAAOkB,MAAM,CAAClB,KAAK;QACnB;MACJ;IACA,KAAK,CAAC,CAAC;MAAyB;QAC5B,MAAMoB,OAAO,GAAG1C,IAAI;QACpB,MAAMmB,KAAK,GAAGuB,OAAO,CAACvB,KAAK;QAC3B,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,KAAK,CAACD,MAAM,EAAEE,CAAC,EAAE,EAAE;UACnCgB,MAAM,CAACjB,KAAK,CAACC,CAAC,CAAC,CAAC;QACpB;QACAsB,OAAO,CAACtB,CAAC,GAAGD,KAAK;QACjB,OAAOuB,OAAO,CAACvB,KAAK;QACpB,IAAIuB,OAAO,CAACC,MAAM,EAAE;UAChBD,OAAO,CAACT,CAAC,GAAGS,OAAO,CAACC,MAAM;UAC1B,OAAOD,OAAO,CAACC,MAAM;QACzB;QACA;MACJ;IACA,KAAK,CAAC,CAAC;IACP,KAAK,CAAC,CAAC;IACP,KAAK,CAAC,CAAC;IACP,KAAK,CAAC,CAAC;MAA2B;QAC9B,MAAMC,SAAS,GAAG5C,IAAI;QACtB,IAAI4C,SAAS,CAAChB,KAAK,EAAE;UACjBgB,SAAS,CAACC,CAAC,GAAGD,SAAS,CAAChB,KAAK;UAC7B,OAAOgB,SAAS,CAAChB,KAAK;QAC1B;QACA;MACJ;IACA,KAAK,CAAC,CAAC;MAAwB;QAC3B,MAAMkB,MAAM,GAAG9C,IAAI;QACnBoC,MAAM,CAACU,MAAM,CAAClC,GAAG,CAAC;QAClBkC,MAAM,CAACC,CAAC,GAAGD,MAAM,CAAClC,GAAG;QACrB,OAAOkC,MAAM,CAAClC,GAAG;QACjB,IAAIkC,MAAM,CAAC9B,QAAQ,EAAE;UACjBoB,MAAM,CAACU,MAAM,CAAC9B,QAAQ,CAAC;UACvB8B,MAAM,CAACE,CAAC,GAAGF,MAAM,CAAC9B,QAAQ;UAC1B,OAAO8B,MAAM,CAAC9B,QAAQ;QAC1B;QACA;MACJ;IACA,KAAK,CAAC,CAAC;MAAsB;QACzB,MAAMiC,IAAI,GAAGjD,IAAI;QACjBiD,IAAI,CAAC7B,CAAC,GAAG6B,IAAI,CAACpB,KAAK;QACnB,OAAOoB,IAAI,CAACpB,KAAK;QACjB;MACJ;IACA,KAAK,CAAC,CAAC;MAAuB;QAC1B,MAAMqB,KAAK,GAAGlD,IAAI;QAClBkD,KAAK,CAACH,CAAC,GAAGG,KAAK,CAACtC,GAAG;QACnB,OAAOsC,KAAK,CAACtC,GAAG;QAChB;MACJ;IACA;MACI,IAAKlC,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAG;QACzC,MAAMT,kBAAkB,CAACnB,iBAAiB,CAACgB,4BAA4B,EAAE,IAAI,EAAE;UAC3EM,MAAM,EAAE6D,cAAc;UACtB3D,IAAI,EAAE,CAACwB,IAAI,CAACyB,IAAI;QACpB,CAAC,CAAC;MACN;EACR;EACA,OAAOzB,IAAI,CAACyB,IAAI;AACpB;AACA;;AAEA,SAAS0B,QAAQA,CAAC/D,GAAG,EAAE;EACnB,MAAMoC,IAAI,GAAGpC,GAAG,CAACoC,IAAI;EACrB,IAAIA,IAAI,CAACC,IAAI,KAAK,CAAC,CAAC,yBAAyB;IACzC2B,mBAAmB,CAAC5B,IAAI,CAAC;EAC7B,CAAC,MACI;IACDA,IAAI,CAACF,KAAK,CAAC+B,OAAO,CAACZ,CAAC,IAAIW,mBAAmB,CAACX,CAAC,CAAC,CAAC;EACnD;EACA,OAAOrD,GAAG;AACd;AACA,SAASgE,mBAAmBA,CAACV,OAAO,EAAE;EAClC,IAAIA,OAAO,CAACvB,KAAK,CAACD,MAAM,KAAK,CAAC,EAAE;IAC5B,MAAMoC,IAAI,GAAGZ,OAAO,CAACvB,KAAK,CAAC,CAAC,CAAC;IAC7B,IAAImC,IAAI,CAAC7B,IAAI,KAAK,CAAC,CAAC,wBAAwB6B,IAAI,CAAC7B,IAAI,KAAK,CAAC,CAAC,yBAAyB;MACjFiB,OAAO,CAACC,MAAM,GAAGW,IAAI,CAAC1B,KAAK;MAC3B,OAAO0B,IAAI,CAAC1B,KAAK,CAAC,CAAC;IACvB;EACJ,CAAC,MACI;IACD,MAAM2B,MAAM,GAAG,EAAE;IACjB,KAAK,IAAInC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGsB,OAAO,CAACvB,KAAK,CAACD,MAAM,EAAEE,CAAC,EAAE,EAAE;MAC3C,MAAMkC,IAAI,GAAGZ,OAAO,CAACvB,KAAK,CAACC,CAAC,CAAC;MAC7B,IAAI,EAAEkC,IAAI,CAAC7B,IAAI,KAAK,CAAC,CAAC,wBAAwB6B,IAAI,CAAC7B,IAAI,KAAK,CAAC,CAAC,wBAAwB,EAAE;QACpF;MACJ;MACA,IAAI6B,IAAI,CAAC1B,KAAK,IAAI,IAAI,EAAE;QACpB;MACJ;MACA2B,MAAM,CAACxD,IAAI,CAACuD,IAAI,CAAC1B,KAAK,CAAC;IAC3B;IACA,IAAI2B,MAAM,CAACrC,MAAM,KAAKwB,OAAO,CAACvB,KAAK,CAACD,MAAM,EAAE;MACxCwB,OAAO,CAACC,MAAM,GAAGvG,IAAI,CAACmH,MAAM,CAAC;MAC7B,KAAK,IAAInC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGsB,OAAO,CAACvB,KAAK,CAACD,MAAM,EAAEE,CAAC,EAAE,EAAE;QAC3C,MAAMkC,IAAI,GAAGZ,OAAO,CAACvB,KAAK,CAACC,CAAC,CAAC;QAC7B,IAAIkC,IAAI,CAAC7B,IAAI,KAAK,CAAC,CAAC,wBAAwB6B,IAAI,CAAC7B,IAAI,KAAK,CAAC,CAAC,yBAAyB;UACjF,OAAO6B,IAAI,CAAC1B,KAAK,CAAC,CAAC;QACvB;MACJ;IACJ;EACJ;AACJ;AAEA,MAAM4B,OAAO,GAAG,GAAG;AACnB,MAAMC,OAAO,GAAG,IAAI;AACpB,MAAMC,OAAO,GAAG,IAAI;AACpB,MAAMC,OAAO,GAAG5E,MAAM,CAAC6E,YAAY,CAAC,MAAM,CAAC;AAC3C,MAAMC,OAAO,GAAG9E,MAAM,CAAC6E,YAAY,CAAC,MAAM,CAAC;AAC3C,SAASE,aAAaA,CAACC,GAAG,EAAE;EACxB,MAAMC,IAAI,GAAGD,GAAG;EAChB,IAAIE,MAAM,GAAG,CAAC;EACd,IAAIC,KAAK,GAAG,CAAC;EACb,IAAIC,OAAO,GAAG,CAAC;EACf,IAAIC,WAAW,GAAG,CAAC;EACnB,MAAMC,MAAM,GAAIxC,KAAK,IAAKmC,IAAI,CAACnC,KAAK,CAAC,KAAK4B,OAAO,IAAIO,IAAI,CAACnC,KAAK,GAAG,CAAC,CAAC,KAAK6B,OAAO;EAChF,MAAMY,IAAI,GAAIzC,KAAK,IAAKmC,IAAI,CAACnC,KAAK,CAAC,KAAK6B,OAAO;EAC/C,MAAMa,IAAI,GAAI1C,KAAK,IAAKmC,IAAI,CAACnC,KAAK,CAAC,KAAKgC,OAAO;EAC/C,MAAMW,IAAI,GAAI3C,KAAK,IAAKmC,IAAI,CAACnC,KAAK,CAAC,KAAK8B,OAAO;EAC/C,MAAMc,SAAS,GAAI5C,KAAK,IAAKwC,MAAM,CAACxC,KAAK,CAAC,IAAIyC,IAAI,CAACzC,KAAK,CAAC,IAAI0C,IAAI,CAAC1C,KAAK,CAAC,IAAI2C,IAAI,CAAC3C,KAAK,CAAC;EACvF,MAAMA,KAAK,GAAGA,CAAA,KAAMoC,MAAM;EAC1B,MAAMzH,IAAI,GAAGA,CAAA,KAAM0H,KAAK;EACxB,MAAMzH,MAAM,GAAGA,CAAA,KAAM0H,OAAO;EAC5B,MAAMO,UAAU,GAAGA,CAAA,KAAMN,WAAW;EACpC,MAAMO,MAAM,GAAIjI,MAAM,IAAK2H,MAAM,CAAC3H,MAAM,CAAC,IAAI6H,IAAI,CAAC7H,MAAM,CAAC,IAAI8H,IAAI,CAAC9H,MAAM,CAAC,GAAGgH,OAAO,GAAGM,IAAI,CAACtH,MAAM,CAAC;EAClG,MAAMkI,WAAW,GAAGA,CAAA,KAAMD,MAAM,CAACV,MAAM,CAAC;EACxC,MAAMY,WAAW,GAAGA,CAAA,KAAMF,MAAM,CAACV,MAAM,GAAGG,WAAW,CAAC;EACtD,SAASU,IAAIA,CAAA,EAAG;IACZV,WAAW,GAAG,CAAC;IACf,IAAIK,SAAS,CAACR,MAAM,CAAC,EAAE;MACnBC,KAAK,EAAE;MACPC,OAAO,GAAG,CAAC;IACf;IACA,IAAIE,MAAM,CAACJ,MAAM,CAAC,EAAE;MAChBA,MAAM,EAAE;IACZ;IACAA,MAAM,EAAE;IACRE,OAAO,EAAE;IACT,OAAOH,IAAI,CAACC,MAAM,CAAC;EACvB;EACA,SAASc,IAAIA,CAAA,EAAG;IACZ,IAAIV,MAAM,CAACJ,MAAM,GAAGG,WAAW,CAAC,EAAE;MAC9BA,WAAW,EAAE;IACjB;IACAA,WAAW,EAAE;IACb,OAAOJ,IAAI,CAACC,MAAM,GAAGG,WAAW,CAAC;EACrC;EACA,SAASY,KAAKA,CAAA,EAAG;IACbf,MAAM,GAAG,CAAC;IACVC,KAAK,GAAG,CAAC;IACTC,OAAO,GAAG,CAAC;IACXC,WAAW,GAAG,CAAC;EACnB;EACA,SAASa,SAASA,CAACvI,MAAM,GAAG,CAAC,EAAE;IAC3B0H,WAAW,GAAG1H,MAAM;EACxB;EACA,SAASwI,UAAUA,CAAA,EAAG;IAClB,MAAMC,MAAM,GAAGlB,MAAM,GAAGG,WAAW;IACnC,OAAOe,MAAM,KAAKlB,MAAM,EAAE;MACtBa,IAAI,CAAC,CAAC;IACV;IACAV,WAAW,GAAG,CAAC;EACnB;EACA,OAAO;IACHvC,KAAK;IACLrF,IAAI;IACJC,MAAM;IACNiI,UAAU;IACVC,MAAM;IACNC,WAAW;IACXC,WAAW;IACXC,IAAI;IACJC,IAAI;IACJC,KAAK;IACLC,SAAS;IACTC;EACJ,CAAC;AACL;AAEA,MAAME,GAAG,GAAGxF,SAAS;AACrB,MAAMyF,GAAG,GAAG,GAAG;AACf,MAAMC,iBAAiB,GAAG,GAAG;AAC7B,MAAMC,cAAc,GAAG,WAAW;AAClC,SAASC,eAAeA,CAAC1I,MAAM,EAAEuB,OAAO,GAAG,CAAC,CAAC,EAAE;EAC3C,MAAMW,QAAQ,GAAGX,OAAO,CAACW,QAAQ,KAAK,KAAK;EAC3C,MAAMyG,KAAK,GAAG3B,aAAa,CAAChH,MAAM,CAAC;EACnC,MAAM4I,aAAa,GAAGA,CAAA,KAAMD,KAAK,CAAC5D,KAAK,CAAC,CAAC;EACzC,MAAM8D,eAAe,GAAGA,CAAA,KAAM/I,cAAc,CAAC6I,KAAK,CAACjJ,IAAI,CAAC,CAAC,EAAEiJ,KAAK,CAAChJ,MAAM,CAAC,CAAC,EAAEgJ,KAAK,CAAC5D,KAAK,CAAC,CAAC,CAAC;EACzF,MAAM+D,QAAQ,GAAGD,eAAe,CAAC,CAAC;EAClC,MAAME,WAAW,GAAGH,aAAa,CAAC,CAAC;EACnC,MAAMhG,QAAQ,GAAG;IACboG,WAAW,EAAE,EAAE,CAAC;IAChBpJ,MAAM,EAAEmJ,WAAW;IACnBE,QAAQ,EAAEH,QAAQ;IAClBI,MAAM,EAAEJ,QAAQ;IAChBK,QAAQ,EAAE,EAAE,CAAC;IACbC,UAAU,EAAEL,WAAW;IACvBM,YAAY,EAAEP,QAAQ;IACtBQ,UAAU,EAAER,QAAQ;IACpBS,SAAS,EAAE,CAAC;IACZC,QAAQ,EAAE,KAAK;IACfC,IAAI,EAAE;EACV,CAAC;EACD,MAAMzG,OAAO,GAAGA,CAAA,KAAMJ,QAAQ;EAC9B,MAAM;IAAE8G;EAAQ,CAAC,GAAGnI,OAAO;EAC3B,SAASoI,SAASA,CAACrI,IAAI,EAAEsI,GAAG,EAAEhK,MAAM,EAAE,GAAG8B,IAAI,EAAE;IAC3C,MAAMmI,GAAG,GAAG7G,OAAO,CAAC,CAAC;IACrB4G,GAAG,CAACjK,MAAM,IAAIC,MAAM;IACpBgK,GAAG,CAAChK,MAAM,IAAIA,MAAM;IACpB,IAAI8J,OAAO,EAAE;MACT,MAAMzJ,GAAG,GAAGiC,QAAQ,GAAGnC,cAAc,CAAC8J,GAAG,CAACZ,QAAQ,EAAEW,GAAG,CAAC,GAAG,IAAI;MAC/D,MAAME,GAAG,GAAGzI,kBAAkB,CAACC,IAAI,EAAErB,GAAG,EAAE;QACtCuB,MAAM,EAAEiH,cAAc;QACtB/G;MACJ,CAAC,CAAC;MACFgI,OAAO,CAACI,GAAG,CAAC;IAChB;EACJ;EACA,SAASC,QAAQA,CAAC/G,OAAO,EAAE2B,IAAI,EAAEG,KAAK,EAAE;IACpC9B,OAAO,CAACkG,MAAM,GAAGL,eAAe,CAAC,CAAC;IAClC7F,OAAO,CAACgG,WAAW,GAAGrE,IAAI;IAC1B,MAAMqF,KAAK,GAAG;MAAErF;IAAK,CAAC;IACtB,IAAIzC,QAAQ,EAAE;MACV8H,KAAK,CAAC/J,GAAG,GAAGF,cAAc,CAACiD,OAAO,CAACiG,QAAQ,EAAEjG,OAAO,CAACkG,MAAM,CAAC;IAChE;IACA,IAAIpE,KAAK,IAAI,IAAI,EAAE;MACfkF,KAAK,CAAClF,KAAK,GAAGA,KAAK;IACvB;IACA,OAAOkF,KAAK;EAChB;EACA,MAAMC,WAAW,GAAIjH,OAAO,IAAK+G,QAAQ,CAAC/G,OAAO,EAAE,EAAE,CAAC,oBAAoB,CAAC;EAC3E,SAASkH,GAAGA,CAACC,IAAI,EAAEC,EAAE,EAAE;IACnB,IAAID,IAAI,CAACrC,WAAW,CAAC,CAAC,KAAKsC,EAAE,EAAE;MAC3BD,IAAI,CAACnC,IAAI,CAAC,CAAC;MACX,OAAOoC,EAAE;IACb,CAAC,MACI;MACDT,SAAS,CAACzJ,iBAAiB,CAACC,cAAc,EAAE0I,eAAe,CAAC,CAAC,EAAE,CAAC,EAAEuB,EAAE,CAAC;MACrE,OAAO,EAAE;IACb;EACJ;EACA,SAASC,UAAUA,CAACF,IAAI,EAAE;IACtB,IAAIG,GAAG,GAAG,EAAE;IACZ,OAAOH,IAAI,CAACpC,WAAW,CAAC,CAAC,KAAKrB,OAAO,IAAIyD,IAAI,CAACpC,WAAW,CAAC,CAAC,KAAKnB,OAAO,EAAE;MACrE0D,GAAG,IAAIH,IAAI,CAACpC,WAAW,CAAC,CAAC;MACzBoC,IAAI,CAAClC,IAAI,CAAC,CAAC;IACf;IACA,OAAOqC,GAAG;EACd;EACA,SAASC,UAAUA,CAACJ,IAAI,EAAE;IACtB,MAAMG,GAAG,GAAGD,UAAU,CAACF,IAAI,CAAC;IAC5BA,IAAI,CAAC/B,UAAU,CAAC,CAAC;IACjB,OAAOkC,GAAG;EACd;EACA,SAASE,iBAAiBA,CAACJ,EAAE,EAAE;IAC3B,IAAIA,EAAE,KAAK9B,GAAG,EAAE;MACZ,OAAO,KAAK;IAChB;IACA,MAAMmC,EAAE,GAAGL,EAAE,CAACM,UAAU,CAAC,CAAC,CAAC;IAC3B,OAASD,EAAE,IAAI,EAAE,IAAIA,EAAE,IAAI,GAAG;IAAK;IAC9BA,EAAE,IAAI,EAAE,IAAIA,EAAE,IAAI,EAAG;IAAI;IAC1BA,EAAE,KAAK,EAAE,CAAC;IAAA;EAElB;EACA,SAASE,aAAaA,CAACP,EAAE,EAAE;IACvB,IAAIA,EAAE,KAAK9B,GAAG,EAAE;MACZ,OAAO,KAAK;IAChB;IACA,MAAMmC,EAAE,GAAGL,EAAE,CAACM,UAAU,CAAC,CAAC,CAAC;IAC3B,OAAOD,EAAE,IAAI,EAAE,IAAIA,EAAE,IAAI,EAAE,CAAC,CAAC;EACjC;EACA,SAASG,sBAAsBA,CAACT,IAAI,EAAEnH,OAAO,EAAE;IAC3C,MAAM;MAAEgG;IAAY,CAAC,GAAGhG,OAAO;IAC/B,IAAIgG,WAAW,KAAK,CAAC,CAAC,4BAA4B;MAC9C,OAAO,KAAK;IAChB;IACAqB,UAAU,CAACF,IAAI,CAAC;IAChB,MAAMU,GAAG,GAAGL,iBAAiB,CAACL,IAAI,CAACpC,WAAW,CAAC,CAAC,CAAC;IACjDoC,IAAI,CAAChC,SAAS,CAAC,CAAC;IAChB,OAAO0C,GAAG;EACd;EACA,SAASC,qBAAqBA,CAACX,IAAI,EAAEnH,OAAO,EAAE;IAC1C,MAAM;MAAEgG;IAAY,CAAC,GAAGhG,OAAO;IAC/B,IAAIgG,WAAW,KAAK,CAAC,CAAC,4BAA4B;MAC9C,OAAO,KAAK;IAChB;IACAqB,UAAU,CAACF,IAAI,CAAC;IAChB,MAAMC,EAAE,GAAGD,IAAI,CAACpC,WAAW,CAAC,CAAC,KAAK,GAAG,GAAGoC,IAAI,CAAClC,IAAI,CAAC,CAAC,GAAGkC,IAAI,CAACpC,WAAW,CAAC,CAAC;IACxE,MAAM8C,GAAG,GAAGF,aAAa,CAACP,EAAE,CAAC;IAC7BD,IAAI,CAAChC,SAAS,CAAC,CAAC;IAChB,OAAO0C,GAAG;EACd;EACA,SAASE,cAAcA,CAACZ,IAAI,EAAEnH,OAAO,EAAE;IACnC,MAAM;MAAEgG;IAAY,CAAC,GAAGhG,OAAO;IAC/B,IAAIgG,WAAW,KAAK,CAAC,CAAC,4BAA4B;MAC9C,OAAO,KAAK;IAChB;IACAqB,UAAU,CAACF,IAAI,CAAC;IAChB,MAAMU,GAAG,GAAGV,IAAI,CAACpC,WAAW,CAAC,CAAC,KAAKS,iBAAiB;IACpD2B,IAAI,CAAChC,SAAS,CAAC,CAAC;IAChB,OAAO0C,GAAG;EACd;EACA,SAASG,gBAAgBA,CAACb,IAAI,EAAEnH,OAAO,EAAE;IACrC,MAAM;MAAEgG;IAAY,CAAC,GAAGhG,OAAO;IAC/B,IAAIgG,WAAW,KAAK,CAAC,CAAC,8BAA8B;MAChD,OAAO,KAAK;IAChB;IACAqB,UAAU,CAACF,IAAI,CAAC;IAChB,MAAMU,GAAG,GAAGV,IAAI,CAACpC,WAAW,CAAC,CAAC,KAAK,GAAG,CAAC;IACvCoC,IAAI,CAAChC,SAAS,CAAC,CAAC;IAChB,OAAO0C,GAAG;EACd;EACA,SAASI,qBAAqBA,CAACd,IAAI,EAAEnH,OAAO,EAAE;IAC1C,MAAM;MAAEgG;IAAY,CAAC,GAAGhG,OAAO;IAC/B,IAAIgG,WAAW,KAAK,CAAC,CAAC,4BAA4B;MAC9C,OAAO,KAAK;IAChB;IACAqB,UAAU,CAACF,IAAI,CAAC;IAChB,MAAMU,GAAG,GAAGL,iBAAiB,CAACL,IAAI,CAACpC,WAAW,CAAC,CAAC,CAAC;IACjDoC,IAAI,CAAChC,SAAS,CAAC,CAAC;IAChB,OAAO0C,GAAG;EACd;EACA,SAASK,sBAAsBA,CAACf,IAAI,EAAEnH,OAAO,EAAE;IAC3C,MAAM;MAAEgG;IAAY,CAAC,GAAGhG,OAAO;IAC/B,IAAI,EAAEgG,WAAW,KAAK,CAAC,CAAC,gCACpBA,WAAW,KAAK,EAAE,CAAC,gCAAgC,EAAE;MACrD,OAAO,KAAK;IAChB;IACAqB,UAAU,CAACF,IAAI,CAAC;IAChB,MAAMU,GAAG,GAAGV,IAAI,CAACpC,WAAW,CAAC,CAAC,KAAK,GAAG,CAAC;IACvCoC,IAAI,CAAChC,SAAS,CAAC,CAAC;IAChB,OAAO0C,GAAG;EACd;EACA,SAASM,kBAAkBA,CAAChB,IAAI,EAAEnH,OAAO,EAAE;IACvC,MAAM;MAAEgG;IAAY,CAAC,GAAGhG,OAAO;IAC/B,IAAIgG,WAAW,KAAK,CAAC,CAAC,kCAAkC;MACpD,OAAO,KAAK;IAChB;IACA,MAAMoC,EAAE,GAAGA,CAAA,KAAM;MACb,MAAMhB,EAAE,GAAGD,IAAI,CAACpC,WAAW,CAAC,CAAC;MAC7B,IAAIqC,EAAE,KAAK,GAAG,CAAC,4BAA4B;QACvC,OAAOI,iBAAiB,CAACL,IAAI,CAAClC,IAAI,CAAC,CAAC,CAAC;MACzC,CAAC,MACI,IAAImC,EAAE,KAAK,GAAG,CAAC,gCAChBA,EAAE,KAAK,GAAG,CAAC,yBACXA,EAAE,KAAK,GAAG,CAAC,oCACXA,EAAE,KAAK,GAAG,CAAC,8BACXA,EAAE,KAAK1D,OAAO,IACd,CAAC0D,EAAE,EAAE;QACL,OAAO,KAAK;MAChB,CAAC,MACI,IAAIA,EAAE,KAAKxD,OAAO,EAAE;QACrBuD,IAAI,CAAClC,IAAI,CAAC,CAAC;QACX,OAAOmD,EAAE,CAAC,CAAC;MACf,CAAC,MACI;QACD;QACA,OAAOC,WAAW,CAAClB,IAAI,EAAE,KAAK,CAAC;MACnC;IACJ,CAAC;IACD,MAAMU,GAAG,GAAGO,EAAE,CAAC,CAAC;IAChBjB,IAAI,CAAChC,SAAS,CAAC,CAAC;IAChB,OAAO0C,GAAG;EACd;EACA,SAASS,aAAaA,CAACnB,IAAI,EAAE;IACzBE,UAAU,CAACF,IAAI,CAAC;IAChB,MAAMU,GAAG,GAAGV,IAAI,CAACpC,WAAW,CAAC,CAAC,KAAK,GAAG,CAAC;IACvCoC,IAAI,CAAChC,SAAS,CAAC,CAAC;IAChB,OAAO0C,GAAG;EACd;EACA,SAASQ,WAAWA,CAAClB,IAAI,EAAEjC,KAAK,GAAG,IAAI,EAAE;IACrC,MAAMkD,EAAE,GAAGA,CAACG,QAAQ,GAAG,KAAK,EAAEC,IAAI,GAAG,EAAE,KAAK;MACxC,MAAMpB,EAAE,GAAGD,IAAI,CAACpC,WAAW,CAAC,CAAC;MAC7B,IAAIqC,EAAE,KAAK,GAAG,CAAC,4BAA4B;QACvC,OAAOmB,QAAQ;MACnB,CAAC,MACI,IAAInB,EAAE,KAAK,GAAG,CAAC,gCAAgC,CAACA,EAAE,EAAE;QACrD,OAAOmB,QAAQ;MACnB,CAAC,MACI,IAAInB,EAAE,KAAK,GAAG,CAAC,uBAAuB;QACvC,OAAO,EAAEoB,IAAI,KAAK9E,OAAO,IAAI8E,IAAI,KAAK5E,OAAO,CAAC;MAClD,CAAC,MACI,IAAIwD,EAAE,KAAK1D,OAAO,EAAE;QACrByD,IAAI,CAAClC,IAAI,CAAC,CAAC;QACX,OAAOmD,EAAE,CAAC,IAAI,EAAE1E,OAAO,CAAC;MAC5B,CAAC,MACI,IAAI0D,EAAE,KAAKxD,OAAO,EAAE;QACrBuD,IAAI,CAAClC,IAAI,CAAC,CAAC;QACX,OAAOmD,EAAE,CAAC,IAAI,EAAExE,OAAO,CAAC;MAC5B,CAAC,MACI;QACD,OAAO,IAAI;MACf;IACJ,CAAC;IACD,MAAMiE,GAAG,GAAGO,EAAE,CAAC,CAAC;IAChBlD,KAAK,IAAIiC,IAAI,CAAChC,SAAS,CAAC,CAAC;IACzB,OAAO0C,GAAG;EACd;EACA,SAASY,QAAQA,CAACtB,IAAI,EAAEiB,EAAE,EAAE;IACxB,MAAMhB,EAAE,GAAGD,IAAI,CAACrC,WAAW,CAAC,CAAC;IAC7B,IAAIsC,EAAE,KAAK9B,GAAG,EAAE;MACZ,OAAOA,GAAG;IACd;IACA,IAAI8C,EAAE,CAAChB,EAAE,CAAC,EAAE;MACRD,IAAI,CAACnC,IAAI,CAAC,CAAC;MACX,OAAOoC,EAAE;IACb;IACA,OAAO,IAAI;EACf;EACA,SAASsB,YAAYA,CAACtB,EAAE,EAAE;IACtB,MAAMK,EAAE,GAAGL,EAAE,CAACM,UAAU,CAAC,CAAC,CAAC;IAC3B,OAASD,EAAE,IAAI,EAAE,IAAIA,EAAE,IAAI,GAAG;IAAK;IAC9BA,EAAE,IAAI,EAAE,IAAIA,EAAE,IAAI,EAAG;IAAI;IACzBA,EAAE,IAAI,EAAE,IAAIA,EAAE,IAAI,EAAG;IAAI;IAC1BA,EAAE,KAAK,EAAE;IAAI;IACbA,EAAE,KAAK,EAAE,CAAC;IAAA;EAElB;EACA,SAASkB,kBAAkBA,CAACxB,IAAI,EAAE;IAC9B,OAAOsB,QAAQ,CAACtB,IAAI,EAAEuB,YAAY,CAAC;EACvC;EACA,SAASE,iBAAiBA,CAACxB,EAAE,EAAE;IAC3B,MAAMK,EAAE,GAAGL,EAAE,CAACM,UAAU,CAAC,CAAC,CAAC;IAC3B,OAASD,EAAE,IAAI,EAAE,IAAIA,EAAE,IAAI,GAAG;IAAK;IAC9BA,EAAE,IAAI,EAAE,IAAIA,EAAE,IAAI,EAAG;IAAI;IACzBA,EAAE,IAAI,EAAE,IAAIA,EAAE,IAAI,EAAG;IAAI;IAC1BA,EAAE,KAAK,EAAE;IAAI;IACbA,EAAE,KAAK,EAAE;IAAI;IACbA,EAAE,KAAK,EAAE,CAAC;IAAA;EAElB;EACA,SAASoB,uBAAuBA,CAAC1B,IAAI,EAAE;IACnC,OAAOsB,QAAQ,CAACtB,IAAI,EAAEyB,iBAAiB,CAAC;EAC5C;EACA,SAASE,OAAOA,CAAC1B,EAAE,EAAE;IACjB,MAAMK,EAAE,GAAGL,EAAE,CAACM,UAAU,CAAC,CAAC,CAAC;IAC3B,OAAOD,EAAE,IAAI,EAAE,IAAIA,EAAE,IAAI,EAAE,CAAC,CAAC;EACjC;EACA,SAASsB,SAASA,CAAC5B,IAAI,EAAE;IACrB,OAAOsB,QAAQ,CAACtB,IAAI,EAAE2B,OAAO,CAAC;EAClC;EACA,SAASE,UAAUA,CAAC5B,EAAE,EAAE;IACpB,MAAMK,EAAE,GAAGL,EAAE,CAACM,UAAU,CAAC,CAAC,CAAC;IAC3B,OAASD,EAAE,IAAI,EAAE,IAAIA,EAAE,IAAI,EAAE;IAAK;IAC7BA,EAAE,IAAI,EAAE,IAAIA,EAAE,IAAI,EAAG;IAAI;IACzBA,EAAE,IAAI,EAAE,IAAIA,EAAE,IAAI,GAAI,CAAE,CAAC;EAClC;EACA,SAASwB,YAAYA,CAAC9B,IAAI,EAAE;IACxB,OAAOsB,QAAQ,CAACtB,IAAI,EAAE6B,UAAU,CAAC;EACrC;EACA,SAASE,SAASA,CAAC/B,IAAI,EAAE;IACrB,IAAIC,EAAE,GAAG,EAAE;IACX,IAAI+B,GAAG,GAAG,EAAE;IACZ,OAAQ/B,EAAE,GAAG2B,SAAS,CAAC5B,IAAI,CAAC,EAAG;MAC3BgC,GAAG,IAAI/B,EAAE;IACb;IACA,OAAO+B,GAAG;EACd;EACA,SAASC,QAAQA,CAACjC,IAAI,EAAE;IACpB,IAAIG,GAAG,GAAG,EAAE;IACZ,OAAO,IAAI,EAAE;MACT,MAAMF,EAAE,GAAGD,IAAI,CAACrC,WAAW,CAAC,CAAC;MAC7B,IAAIsC,EAAE,KAAK,GAAG,CAAC,8BACXA,EAAE,KAAK,GAAG,CAAC,+BACXA,EAAE,KAAK,GAAG,CAAC,gCACXA,EAAE,KAAK,GAAG,CAAC,yBACX,CAACA,EAAE,EAAE;QACL;MACJ,CAAC,MACI,IAAIA,EAAE,KAAK1D,OAAO,IAAI0D,EAAE,KAAKxD,OAAO,EAAE;QACvC,IAAIyE,WAAW,CAAClB,IAAI,CAAC,EAAE;UACnBG,GAAG,IAAIF,EAAE;UACTD,IAAI,CAACnC,IAAI,CAAC,CAAC;QACf,CAAC,MACI,IAAIsD,aAAa,CAACnB,IAAI,CAAC,EAAE;UAC1B;QACJ,CAAC,MACI;UACDG,GAAG,IAAIF,EAAE;UACTD,IAAI,CAACnC,IAAI,CAAC,CAAC;QACf;MACJ,CAAC,MACI;QACDsC,GAAG,IAAIF,EAAE;QACTD,IAAI,CAACnC,IAAI,CAAC,CAAC;MACf;IACJ;IACA,OAAOsC,GAAG;EACd;EACA,SAAS+B,mBAAmBA,CAAClC,IAAI,EAAE;IAC/BI,UAAU,CAACJ,IAAI,CAAC;IAChB,IAAIC,EAAE,GAAG,EAAE;IACX,IAAIkC,IAAI,GAAG,EAAE;IACb,OAAQlC,EAAE,GAAGyB,uBAAuB,CAAC1B,IAAI,CAAC,EAAG;MACzCmC,IAAI,IAAIlC,EAAE;IACd;IACA,IAAID,IAAI,CAACrC,WAAW,CAAC,CAAC,KAAKQ,GAAG,EAAE;MAC5BqB,SAAS,CAACzJ,iBAAiB,CAACO,0BAA0B,EAAEoI,eAAe,CAAC,CAAC,EAAE,CAAC,CAAC;IACjF;IACA,OAAOyD,IAAI;EACf;EACA,SAASC,kBAAkBA,CAACpC,IAAI,EAAE;IAC9BI,UAAU,CAACJ,IAAI,CAAC;IAChB,IAAIrF,KAAK,GAAG,EAAE;IACd,IAAIqF,IAAI,CAACrC,WAAW,CAAC,CAAC,KAAK,GAAG,EAAE;MAC5BqC,IAAI,CAACnC,IAAI,CAAC,CAAC;MACXlD,KAAK,IAAI,IAAIoH,SAAS,CAAC/B,IAAI,CAAC,EAAE;IAClC,CAAC,MACI;MACDrF,KAAK,IAAIoH,SAAS,CAAC/B,IAAI,CAAC;IAC5B;IACA,IAAIA,IAAI,CAACrC,WAAW,CAAC,CAAC,KAAKQ,GAAG,EAAE;MAC5BqB,SAAS,CAACzJ,iBAAiB,CAACO,0BAA0B,EAAEoI,eAAe,CAAC,CAAC,EAAE,CAAC,CAAC;IACjF;IACA,OAAO/D,KAAK;EAChB;EACA,SAAS0H,SAASA,CAACpC,EAAE,EAAE;IACnB,OAAOA,EAAE,KAAK5B,iBAAiB,IAAI4B,EAAE,KAAKxD,OAAO;EACrD;EACA,SAAS6F,WAAWA,CAACtC,IAAI,EAAE;IACvBI,UAAU,CAACJ,IAAI,CAAC;IAChB;IACAD,GAAG,CAACC,IAAI,EAAE,IAAI,CAAC;IACf,IAAIC,EAAE,GAAG,EAAE;IACX,IAAIsC,OAAO,GAAG,EAAE;IAChB,OAAQtC,EAAE,GAAGqB,QAAQ,CAACtB,IAAI,EAAEqC,SAAS,CAAC,EAAG;MACrC,IAAIpC,EAAE,KAAK,IAAI,EAAE;QACbsC,OAAO,IAAIC,kBAAkB,CAACxC,IAAI,CAAC;MACvC,CAAC,MACI;QACDuC,OAAO,IAAItC,EAAE;MACjB;IACJ;IACA,MAAMwC,OAAO,GAAGzC,IAAI,CAACrC,WAAW,CAAC,CAAC;IAClC,IAAI8E,OAAO,KAAKhG,OAAO,IAAIgG,OAAO,KAAKtE,GAAG,EAAE;MACxCqB,SAAS,CAACzJ,iBAAiB,CAACG,wCAAwC,EAAEwI,eAAe,CAAC,CAAC,EAAE,CAAC,CAAC;MAC3F;MACA,IAAI+D,OAAO,KAAKhG,OAAO,EAAE;QACrBuD,IAAI,CAACnC,IAAI,CAAC,CAAC;QACX;QACAkC,GAAG,CAACC,IAAI,EAAE,IAAI,CAAC;MACnB;MACA,OAAOuC,OAAO;IAClB;IACA;IACAxC,GAAG,CAACC,IAAI,EAAE,IAAI,CAAC;IACf,OAAOuC,OAAO;EAClB;EACA,SAASC,kBAAkBA,CAACxC,IAAI,EAAE;IAC9B,MAAMC,EAAE,GAAGD,IAAI,CAACrC,WAAW,CAAC,CAAC;IAC7B,QAAQsC,EAAE;MACN,KAAK,IAAI;MACT,KAAK,IAAI;QAAE;QACPD,IAAI,CAACnC,IAAI,CAAC,CAAC;QACX,OAAO,KAAKoC,EAAE,EAAE;MACpB,KAAK,GAAG;QACJ,OAAOyC,yBAAyB,CAAC1C,IAAI,EAAEC,EAAE,EAAE,CAAC,CAAC;MACjD,KAAK,GAAG;QACJ,OAAOyC,yBAAyB,CAAC1C,IAAI,EAAEC,EAAE,EAAE,CAAC,CAAC;MACjD;QACIT,SAAS,CAACzJ,iBAAiB,CAACI,uBAAuB,EAAEuI,eAAe,CAAC,CAAC,EAAE,CAAC,EAAEuB,EAAE,CAAC;QAC9E,OAAO,EAAE;IACjB;EACJ;EACA,SAASyC,yBAAyBA,CAAC1C,IAAI,EAAE2C,OAAO,EAAEC,MAAM,EAAE;IACtD7C,GAAG,CAACC,IAAI,EAAE2C,OAAO,CAAC;IAClB,IAAIE,QAAQ,GAAG,EAAE;IACjB,KAAK,IAAI1I,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGyI,MAAM,EAAEzI,CAAC,EAAE,EAAE;MAC7B,MAAM8F,EAAE,GAAG6B,YAAY,CAAC9B,IAAI,CAAC;MAC7B,IAAI,CAACC,EAAE,EAAE;QACLT,SAAS,CAACzJ,iBAAiB,CAACK,+BAA+B,EAAEsI,eAAe,CAAC,CAAC,EAAE,CAAC,EAAE,KAAKiE,OAAO,GAAGE,QAAQ,GAAG7C,IAAI,CAACrC,WAAW,CAAC,CAAC,EAAE,CAAC;QAClI;MACJ;MACAkF,QAAQ,IAAI5C,EAAE;IAClB;IACA,OAAO,KAAK0C,OAAO,GAAGE,QAAQ,EAAE;EACpC;EACA,SAASC,mBAAmBA,CAAC7C,EAAE,EAAE;IAC7B,OAAQA,EAAE,KAAK,GAAG,CAAC,8BACfA,EAAE,KAAK,GAAG,CAAC,+BACXA,EAAE,KAAK1D,OAAO,IACd0D,EAAE,KAAKxD,OAAO;EACtB;EACA,SAASsG,qBAAqBA,CAAC/C,IAAI,EAAE;IACjCI,UAAU,CAACJ,IAAI,CAAC;IAChB,IAAIC,EAAE,GAAG,EAAE;IACX,IAAI+C,WAAW,GAAG,EAAE;IACpB,OAAQ/C,EAAE,GAAGqB,QAAQ,CAACtB,IAAI,EAAE8C,mBAAmB,CAAC,EAAG;MAC/CE,WAAW,IAAI/C,EAAE;IACrB;IACA,OAAO+C,WAAW;EACtB;EACA,SAASC,kBAAkBA,CAACjD,IAAI,EAAE;IAC9B,IAAIC,EAAE,GAAG,EAAE;IACX,IAAIkC,IAAI,GAAG,EAAE;IACb,OAAQlC,EAAE,GAAGuB,kBAAkB,CAACxB,IAAI,CAAC,EAAG;MACpCmC,IAAI,IAAIlC,EAAE;IACd;IACA,OAAOkC,IAAI;EACf;EACA,SAASe,eAAeA,CAAClD,IAAI,EAAE;IAC3B,MAAMiB,EAAE,GAAId,GAAG,IAAK;MAChB,MAAMF,EAAE,GAAGD,IAAI,CAACrC,WAAW,CAAC,CAAC;MAC7B,IAAIsC,EAAE,KAAK,GAAG,CAAC,8BACXA,EAAE,KAAK,GAAG,CAAC,gCACXA,EAAE,KAAK,GAAG,CAAC,yBACXA,EAAE,KAAK,GAAG,CAAC,8BACXA,EAAE,KAAK,GAAG,CAAC,+BACX,CAACA,EAAE,EAAE;QACL,OAAOE,GAAG;MACd,CAAC,MACI,IAAIF,EAAE,KAAK1D,OAAO,EAAE;QACrB,OAAO4D,GAAG;MACd,CAAC,MACI,IAAIF,EAAE,KAAKxD,OAAO,IAAIwD,EAAE,KAAK7B,GAAG,EAAE;QACnC+B,GAAG,IAAIF,EAAE;QACTD,IAAI,CAACnC,IAAI,CAAC,CAAC;QACX,OAAOoD,EAAE,CAACd,GAAG,CAAC;MAClB,CAAC,MACI;QACDA,GAAG,IAAIF,EAAE;QACTD,IAAI,CAACnC,IAAI,CAAC,CAAC;QACX,OAAOoD,EAAE,CAACd,GAAG,CAAC;MAClB;IACJ,CAAC;IACD,OAAOc,EAAE,CAAC,EAAE,CAAC;EACjB;EACA,SAASkC,UAAUA,CAACnD,IAAI,EAAE;IACtBI,UAAU,CAACJ,IAAI,CAAC;IAChB,MAAMzE,MAAM,GAAGwE,GAAG,CAACC,IAAI,EAAE,GAAG,CAAC,qBAAqB,CAAC;IACnDI,UAAU,CAACJ,IAAI,CAAC;IAChB,OAAOzE,MAAM;EACjB;EACA;EACA,SAAS6H,sBAAsBA,CAACpD,IAAI,EAAEnH,OAAO,EAAE;IAC3C,IAAIgH,KAAK,GAAG,IAAI;IAChB,MAAMI,EAAE,GAAGD,IAAI,CAACrC,WAAW,CAAC,CAAC;IAC7B,QAAQsC,EAAE;MACN,KAAK,GAAG,CAAC;QACL,IAAIpH,OAAO,CAACuG,SAAS,IAAI,CAAC,EAAE;UACxBI,SAAS,CAACzJ,iBAAiB,CAACS,0BAA0B,EAAEkI,eAAe,CAAC,CAAC,EAAE,CAAC,CAAC;QACjF;QACAsB,IAAI,CAACnC,IAAI,CAAC,CAAC;QACXgC,KAAK,GAAGD,QAAQ,CAAC/G,OAAO,EAAE,CAAC,CAAC,4BAA4B,GAAG,CAAC,0BAA0B,CAAC;QACvFuH,UAAU,CAACJ,IAAI,CAAC;QAChBnH,OAAO,CAACuG,SAAS,EAAE;QACnB,OAAOS,KAAK;MAChB,KAAK,GAAG,CAAC;QACL,IAAIhH,OAAO,CAACuG,SAAS,GAAG,CAAC,IACrBvG,OAAO,CAACgG,WAAW,KAAK,CAAC,CAAC,4BAA4B;UACtDW,SAAS,CAACzJ,iBAAiB,CAACQ,iBAAiB,EAAEmI,eAAe,CAAC,CAAC,EAAE,CAAC,CAAC;QACxE;QACAsB,IAAI,CAACnC,IAAI,CAAC,CAAC;QACXgC,KAAK,GAAGD,QAAQ,CAAC/G,OAAO,EAAE,CAAC,CAAC,6BAA6B,GAAG,CAAC,2BAA2B,CAAC;QACzFA,OAAO,CAACuG,SAAS,EAAE;QACnBvG,OAAO,CAACuG,SAAS,GAAG,CAAC,IAAIgB,UAAU,CAACJ,IAAI,CAAC;QACzC,IAAInH,OAAO,CAACwG,QAAQ,IAAIxG,OAAO,CAACuG,SAAS,KAAK,CAAC,EAAE;UAC7CvG,OAAO,CAACwG,QAAQ,GAAG,KAAK;QAC5B;QACA,OAAOQ,KAAK;MAChB,KAAK,GAAG,CAAC;QACL,IAAIhH,OAAO,CAACuG,SAAS,GAAG,CAAC,EAAE;UACvBI,SAAS,CAACzJ,iBAAiB,CAACO,0BAA0B,EAAEoI,eAAe,CAAC,CAAC,EAAE,CAAC,CAAC;QACjF;QACAmB,KAAK,GAAGwD,iBAAiB,CAACrD,IAAI,EAAEnH,OAAO,CAAC,IAAIiH,WAAW,CAACjH,OAAO,CAAC;QAChEA,OAAO,CAACuG,SAAS,GAAG,CAAC;QACrB,OAAOS,KAAK;MAChB;QAAS;UACL,IAAIyD,oBAAoB,GAAG,IAAI;UAC/B,IAAIC,mBAAmB,GAAG,IAAI;UAC9B,IAAIC,YAAY,GAAG,IAAI;UACvB,IAAIrC,aAAa,CAACnB,IAAI,CAAC,EAAE;YACrB,IAAInH,OAAO,CAACuG,SAAS,GAAG,CAAC,EAAE;cACvBI,SAAS,CAACzJ,iBAAiB,CAACO,0BAA0B,EAAEoI,eAAe,CAAC,CAAC,EAAE,CAAC,CAAC;YACjF;YACAmB,KAAK,GAAGD,QAAQ,CAAC/G,OAAO,EAAE,CAAC,CAAC,uBAAuBsK,UAAU,CAACnD,IAAI,CAAC,CAAC;YACpE;YACAnH,OAAO,CAACuG,SAAS,GAAG,CAAC;YACrBvG,OAAO,CAACwG,QAAQ,GAAG,KAAK;YACxB,OAAOQ,KAAK;UAChB;UACA,IAAIhH,OAAO,CAACuG,SAAS,GAAG,CAAC,KACpBvG,OAAO,CAACgG,WAAW,KAAK,CAAC,CAAC,0BACvBhG,OAAO,CAACgG,WAAW,KAAK,CAAC,CAAC,yBAC1BhG,OAAO,CAACgG,WAAW,KAAK,CAAC,CAAC,yBAAyB,EAAE;YACzDW,SAAS,CAACzJ,iBAAiB,CAACO,0BAA0B,EAAEoI,eAAe,CAAC,CAAC,EAAE,CAAC,CAAC;YAC7E7F,OAAO,CAACuG,SAAS,GAAG,CAAC;YACrB,OAAOqE,SAAS,CAACzD,IAAI,EAAEnH,OAAO,CAAC;UACnC;UACA,IAAKyK,oBAAoB,GAAG7C,sBAAsB,CAACT,IAAI,EAAEnH,OAAO,CAAC,EAAG;YAChEgH,KAAK,GAAGD,QAAQ,CAAC/G,OAAO,EAAE,CAAC,CAAC,wBAAwBqJ,mBAAmB,CAAClC,IAAI,CAAC,CAAC;YAC9EI,UAAU,CAACJ,IAAI,CAAC;YAChB,OAAOH,KAAK;UAChB;UACA,IAAK0D,mBAAmB,GAAG5C,qBAAqB,CAACX,IAAI,EAAEnH,OAAO,CAAC,EAAG;YAC9DgH,KAAK,GAAGD,QAAQ,CAAC/G,OAAO,EAAE,CAAC,CAAC,uBAAuBuJ,kBAAkB,CAACpC,IAAI,CAAC,CAAC;YAC5EI,UAAU,CAACJ,IAAI,CAAC;YAChB,OAAOH,KAAK;UAChB;UACA,IAAK2D,YAAY,GAAG5C,cAAc,CAACZ,IAAI,EAAEnH,OAAO,CAAC,EAAG;YAChDgH,KAAK,GAAGD,QAAQ,CAAC/G,OAAO,EAAE,CAAC,CAAC,0BAA0ByJ,WAAW,CAACtC,IAAI,CAAC,CAAC;YACxEI,UAAU,CAACJ,IAAI,CAAC;YAChB,OAAOH,KAAK;UAChB;UACA,IAAI,CAACyD,oBAAoB,IAAI,CAACC,mBAAmB,IAAI,CAACC,YAAY,EAAE;YAChE;YACA3D,KAAK,GAAGD,QAAQ,CAAC/G,OAAO,EAAE,EAAE,CAAC,+BAA+BkK,qBAAqB,CAAC/C,IAAI,CAAC,CAAC;YACxFR,SAAS,CAACzJ,iBAAiB,CAACE,4BAA4B,EAAEyI,eAAe,CAAC,CAAC,EAAE,CAAC,EAAEmB,KAAK,CAAClF,KAAK,CAAC;YAC5FyF,UAAU,CAACJ,IAAI,CAAC;YAChB,OAAOH,KAAK;UAChB;UACA;QACJ;IACJ;IACA,OAAOA,KAAK;EAChB;EACA;EACA,SAASwD,iBAAiBA,CAACrD,IAAI,EAAEnH,OAAO,EAAE;IACtC,MAAM;MAAEgG;IAAY,CAAC,GAAGhG,OAAO;IAC/B,IAAIgH,KAAK,GAAG,IAAI;IAChB,MAAMI,EAAE,GAAGD,IAAI,CAACrC,WAAW,CAAC,CAAC;IAC7B,IAAI,CAACkB,WAAW,KAAK,CAAC,CAAC,gCACnBA,WAAW,KAAK,CAAC,CAAC,8BAClBA,WAAW,KAAK,EAAE,CAAC,mCACnBA,WAAW,KAAK,CAAC,CAAC,sCACjBoB,EAAE,KAAKxD,OAAO,IAAIwD,EAAE,KAAK1D,OAAO,CAAC,EAAE;MACpCiD,SAAS,CAACzJ,iBAAiB,CAACU,qBAAqB,EAAEiI,eAAe,CAAC,CAAC,EAAE,CAAC,CAAC;IAC5E;IACA,QAAQuB,EAAE;MACN,KAAK,GAAG,CAAC;QACLD,IAAI,CAACnC,IAAI,CAAC,CAAC;QACXgC,KAAK,GAAGD,QAAQ,CAAC/G,OAAO,EAAE,CAAC,CAAC,8BAA8B,GAAG,CAAC,4BAA4B,CAAC;QAC3FA,OAAO,CAACwG,QAAQ,GAAG,IAAI;QACvB,OAAOQ,KAAK;MAChB,KAAK,GAAG,CAAC;QACLO,UAAU,CAACJ,IAAI,CAAC;QAChBA,IAAI,CAACnC,IAAI,CAAC,CAAC;QACX,OAAO+B,QAAQ,CAAC/G,OAAO,EAAE,CAAC,CAAC,4BAA4B,GAAG,CAAC,0BAA0B,CAAC;MAC1F,KAAK,GAAG,CAAC;QACLuH,UAAU,CAACJ,IAAI,CAAC;QAChBA,IAAI,CAACnC,IAAI,CAAC,CAAC;QACX,OAAO+B,QAAQ,CAAC/G,OAAO,EAAE,CAAC,CAAC,kCAAkC,GAAG,CAAC,gCAAgC,CAAC;MACtG;QACI,IAAIsI,aAAa,CAACnB,IAAI,CAAC,EAAE;UACrBH,KAAK,GAAGD,QAAQ,CAAC/G,OAAO,EAAE,CAAC,CAAC,uBAAuBsK,UAAU,CAACnD,IAAI,CAAC,CAAC;UACpE;UACAnH,OAAO,CAACuG,SAAS,GAAG,CAAC;UACrBvG,OAAO,CAACwG,QAAQ,GAAG,KAAK;UACxB,OAAOQ,KAAK;QAChB;QACA,IAAIgB,gBAAgB,CAACb,IAAI,EAAEnH,OAAO,CAAC,IAC/BkI,sBAAsB,CAACf,IAAI,EAAEnH,OAAO,CAAC,EAAE;UACvCuH,UAAU,CAACJ,IAAI,CAAC;UAChB,OAAOqD,iBAAiB,CAACrD,IAAI,EAAEnH,OAAO,CAAC;QAC3C;QACA,IAAIiI,qBAAqB,CAACd,IAAI,EAAEnH,OAAO,CAAC,EAAE;UACtCuH,UAAU,CAACJ,IAAI,CAAC;UAChB,OAAOJ,QAAQ,CAAC/G,OAAO,EAAE,EAAE,CAAC,iCAAiCoK,kBAAkB,CAACjD,IAAI,CAAC,CAAC;QAC1F;QACA,IAAIgB,kBAAkB,CAAChB,IAAI,EAAEnH,OAAO,CAAC,EAAE;UACnCuH,UAAU,CAACJ,IAAI,CAAC;UAChB,IAAIC,EAAE,KAAK,GAAG,CAAC,4BAA4B;YACvC;YACA,OAAOmD,sBAAsB,CAACpD,IAAI,EAAEnH,OAAO,CAAC,IAAIgH,KAAK;UACzD,CAAC,MACI;YACD,OAAOD,QAAQ,CAAC/G,OAAO,EAAE,EAAE,CAAC,4BAA4BqK,eAAe,CAAClD,IAAI,CAAC,CAAC;UAClF;QACJ;QACA,IAAInB,WAAW,KAAK,CAAC,CAAC,8BAA8B;UAChDW,SAAS,CAACzJ,iBAAiB,CAACU,qBAAqB,EAAEiI,eAAe,CAAC,CAAC,EAAE,CAAC,CAAC;QAC5E;QACA7F,OAAO,CAACuG,SAAS,GAAG,CAAC;QACrBvG,OAAO,CAACwG,QAAQ,GAAG,KAAK;QACxB,OAAOoE,SAAS,CAACzD,IAAI,EAAEnH,OAAO,CAAC;IACvC;EACJ;EACA;EACA,SAAS4K,SAASA,CAACzD,IAAI,EAAEnH,OAAO,EAAE;IAC9B,IAAIgH,KAAK,GAAG;MAAErF,IAAI,EAAE,EAAE,CAAC;IAAqB,CAAC;IAC7C,IAAI3B,OAAO,CAACuG,SAAS,GAAG,CAAC,EAAE;MACvB,OAAOgE,sBAAsB,CAACpD,IAAI,EAAEnH,OAAO,CAAC,IAAIiH,WAAW,CAACjH,OAAO,CAAC;IACxE;IACA,IAAIA,OAAO,CAACwG,QAAQ,EAAE;MAClB,OAAOgE,iBAAiB,CAACrD,IAAI,EAAEnH,OAAO,CAAC,IAAIiH,WAAW,CAACjH,OAAO,CAAC;IACnE;IACA,MAAMoH,EAAE,GAAGD,IAAI,CAACrC,WAAW,CAAC,CAAC;IAC7B,QAAQsC,EAAE;MACN,KAAK,GAAG,CAAC;QACL,OAAOmD,sBAAsB,CAACpD,IAAI,EAAEnH,OAAO,CAAC,IAAIiH,WAAW,CAACjH,OAAO,CAAC;MACxE,KAAK,GAAG,CAAC;QACL2G,SAAS,CAACzJ,iBAAiB,CAACM,wBAAwB,EAAEqI,eAAe,CAAC,CAAC,EAAE,CAAC,CAAC;QAC3EsB,IAAI,CAACnC,IAAI,CAAC,CAAC;QACX,OAAO+B,QAAQ,CAAC/G,OAAO,EAAE,CAAC,CAAC,6BAA6B,GAAG,CAAC,2BAA2B,CAAC;MAC5F,KAAK,GAAG,CAAC;QACL,OAAOwK,iBAAiB,CAACrD,IAAI,EAAEnH,OAAO,CAAC,IAAIiH,WAAW,CAACjH,OAAO,CAAC;MACnE;QAAS;UACL,IAAIsI,aAAa,CAACnB,IAAI,CAAC,EAAE;YACrBH,KAAK,GAAGD,QAAQ,CAAC/G,OAAO,EAAE,CAAC,CAAC,uBAAuBsK,UAAU,CAACnD,IAAI,CAAC,CAAC;YACpE;YACAnH,OAAO,CAACuG,SAAS,GAAG,CAAC;YACrBvG,OAAO,CAACwG,QAAQ,GAAG,KAAK;YACxB,OAAOQ,KAAK;UAChB;UACA,IAAIqB,WAAW,CAAClB,IAAI,CAAC,EAAE;YACnB,OAAOJ,QAAQ,CAAC/G,OAAO,EAAE,CAAC,CAAC,uBAAuBoJ,QAAQ,CAACjC,IAAI,CAAC,CAAC;UACrE;UACA;QACJ;IACJ;IACA,OAAOH,KAAK;EAChB;EACA,SAAS6D,SAASA,CAAA,EAAG;IACjB,MAAM;MAAE7E,WAAW;MAAEpJ,MAAM;MAAEqJ,QAAQ;MAAEC;IAAO,CAAC,GAAGtG,QAAQ;IAC1DA,QAAQ,CAACuG,QAAQ,GAAGH,WAAW;IAC/BpG,QAAQ,CAACwG,UAAU,GAAGxJ,MAAM;IAC5BgD,QAAQ,CAACyG,YAAY,GAAGJ,QAAQ;IAChCrG,QAAQ,CAAC0G,UAAU,GAAGJ,MAAM;IAC5BtG,QAAQ,CAAChD,MAAM,GAAGgJ,aAAa,CAAC,CAAC;IACjChG,QAAQ,CAACqG,QAAQ,GAAGJ,eAAe,CAAC,CAAC;IACrC,IAAIF,KAAK,CAACb,WAAW,CAAC,CAAC,KAAKQ,GAAG,EAAE;MAC7B,OAAOyB,QAAQ,CAACnH,QAAQ,EAAE,EAAE,CAAC,oBAAoB,CAAC;IACtD;IACA,OAAOgL,SAAS,CAACjF,KAAK,EAAE/F,QAAQ,CAAC;EACrC;EACA,OAAO;IACHiL,SAAS;IACTjF,aAAa;IACbC,eAAe;IACf7F;EACJ,CAAC;AACL;AAEA,MAAM8K,YAAY,GAAG,QAAQ;AAC7B;AACA,MAAMC,aAAa,GAAG,uDAAuD;AAC7E,SAASC,kBAAkBA,CAACC,KAAK,EAAEC,UAAU,EAAEC,UAAU,EAAE;EACvD,QAAQF,KAAK;IACT,KAAK,MAAM;MACP,OAAO,IAAI;IACf;IACA,KAAK,MAAM;MACP;MACA,OAAO,IAAI;IACf;MAAS;QACL,MAAMG,SAAS,GAAGC,QAAQ,CAACH,UAAU,IAAIC,UAAU,EAAE,EAAE,CAAC;QACxD,IAAIC,SAAS,IAAI,MAAM,IAAIA,SAAS,IAAI,MAAM,EAAE;UAC5C,OAAOnM,MAAM,CAACqM,aAAa,CAACF,SAAS,CAAC;QAC1C;QACA;QACA;QACA,OAAO,GAAG;MACd;EACJ;AACJ;AACA,SAASG,YAAYA,CAAChN,OAAO,GAAG,CAAC,CAAC,EAAE;EAChC,MAAMW,QAAQ,GAAGX,OAAO,CAACW,QAAQ,KAAK,KAAK;EAC3C,MAAM;IAAEwH;EAAQ,CAAC,GAAGnI,OAAO;EAC3B,SAASoI,SAASA,CAAC6E,QAAQ,EAAElN,IAAI,EAAE7B,KAAK,EAAEG,MAAM,EAAE,GAAG8B,IAAI,EAAE;IACvD,MAAM7B,GAAG,GAAG2O,QAAQ,CAAC3F,eAAe,CAAC,CAAC;IACtChJ,GAAG,CAACD,MAAM,IAAIA,MAAM;IACpBC,GAAG,CAACF,MAAM,IAAIC,MAAM;IACpB,IAAI8J,OAAO,EAAE;MACT,MAAMzJ,GAAG,GAAGiC,QAAQ,GAAGnC,cAAc,CAACN,KAAK,EAAEI,GAAG,CAAC,GAAG,IAAI;MACxD,MAAMiK,GAAG,GAAGzI,kBAAkB,CAACC,IAAI,EAAErB,GAAG,EAAE;QACtCuB,MAAM,EAAEsM,YAAY;QACpBpM;MACJ,CAAC,CAAC;MACFgI,OAAO,CAACI,GAAG,CAAC;IAChB;EACJ;EACA,SAAS2E,SAASA,CAAC9J,IAAI,EAAE/E,MAAM,EAAEK,GAAG,EAAE;IAClC,MAAMiD,IAAI,GAAG;MAAEyB;IAAK,CAAC;IACrB,IAAIzC,QAAQ,EAAE;MACVgB,IAAI,CAACzD,KAAK,GAAGG,MAAM;MACnBsD,IAAI,CAACrD,GAAG,GAAGD,MAAM;MACjBsD,IAAI,CAACjD,GAAG,GAAG;QAAER,KAAK,EAAEQ,GAAG;QAAEJ,GAAG,EAAEI;MAAI,CAAC;IACvC;IACA,OAAOiD,IAAI;EACf;EACA,SAASwL,OAAOA,CAACxL,IAAI,EAAEtD,MAAM,EAAEgK,GAAG,EAAEjF,IAAI,EAAE;IACtC,IAAIzC,QAAQ,EAAE;MACVgB,IAAI,CAACrD,GAAG,GAAGD,MAAM;MACjB,IAAIsD,IAAI,CAACjD,GAAG,EAAE;QACViD,IAAI,CAACjD,GAAG,CAACJ,GAAG,GAAG+J,GAAG;MACtB;IACJ;EACJ;EACA,SAAS+E,SAASA,CAACC,SAAS,EAAE9J,KAAK,EAAE;IACjC,MAAM9B,OAAO,GAAG4L,SAAS,CAAC5L,OAAO,CAAC,CAAC;IACnC,MAAME,IAAI,GAAGuL,SAAS,CAAC,CAAC,CAAC,sBAAsBzL,OAAO,CAACpD,MAAM,EAAEoD,OAAO,CAACiG,QAAQ,CAAC;IAChF/F,IAAI,CAAC4B,KAAK,GAAGA,KAAK;IAClB4J,OAAO,CAACxL,IAAI,EAAE0L,SAAS,CAAChG,aAAa,CAAC,CAAC,EAAEgG,SAAS,CAAC/F,eAAe,CAAC,CAAC,CAAC;IACrE,OAAO3F,IAAI;EACf;EACA,SAAS2L,SAASA,CAACD,SAAS,EAAE7J,KAAK,EAAE;IACjC,MAAM/B,OAAO,GAAG4L,SAAS,CAAC5L,OAAO,CAAC,CAAC;IACnC,MAAM;MAAEoG,UAAU,EAAExJ,MAAM;MAAEyJ,YAAY,EAAEpJ;IAAI,CAAC,GAAG+C,OAAO,CAAC,CAAC;IAC3D,MAAME,IAAI,GAAGuL,SAAS,CAAC,CAAC,CAAC,sBAAsB7O,MAAM,EAAEK,GAAG,CAAC;IAC3DiD,IAAI,CAAC6B,KAAK,GAAGsJ,QAAQ,CAACtJ,KAAK,EAAE,EAAE,CAAC;IAChC6J,SAAS,CAACf,SAAS,CAAC,CAAC,CAAC,CAAC;IACvBa,OAAO,CAACxL,IAAI,EAAE0L,SAAS,CAAChG,aAAa,CAAC,CAAC,EAAEgG,SAAS,CAAC/F,eAAe,CAAC,CAAC,CAAC;IACrE,OAAO3F,IAAI;EACf;EACA,SAAS4L,UAAUA,CAACF,SAAS,EAAE9K,GAAG,EAAE;IAChC,MAAMd,OAAO,GAAG4L,SAAS,CAAC5L,OAAO,CAAC,CAAC;IACnC,MAAM;MAAEoG,UAAU,EAAExJ,MAAM;MAAEyJ,YAAY,EAAEpJ;IAAI,CAAC,GAAG+C,OAAO,CAAC,CAAC;IAC3D,MAAME,IAAI,GAAGuL,SAAS,CAAC,CAAC,CAAC,uBAAuB7O,MAAM,EAAEK,GAAG,CAAC;IAC5DiD,IAAI,CAACY,GAAG,GAAGA,GAAG;IACd8K,SAAS,CAACf,SAAS,CAAC,CAAC,CAAC,CAAC;IACvBa,OAAO,CAACxL,IAAI,EAAE0L,SAAS,CAAChG,aAAa,CAAC,CAAC,EAAEgG,SAAS,CAAC/F,eAAe,CAAC,CAAC,CAAC;IACrE,OAAO3F,IAAI;EACf;EACA,SAAS6L,YAAYA,CAACH,SAAS,EAAE9J,KAAK,EAAE;IACpC,MAAM9B,OAAO,GAAG4L,SAAS,CAAC5L,OAAO,CAAC,CAAC;IACnC,MAAM;MAAEoG,UAAU,EAAExJ,MAAM;MAAEyJ,YAAY,EAAEpJ;IAAI,CAAC,GAAG+C,OAAO,CAAC,CAAC;IAC3D,MAAME,IAAI,GAAGuL,SAAS,CAAC,CAAC,CAAC,yBAAyB7O,MAAM,EAAEK,GAAG,CAAC;IAC9DiD,IAAI,CAAC4B,KAAK,GAAGA,KAAK,CAACkK,OAAO,CAACjB,aAAa,EAAEC,kBAAkB,CAAC;IAC7DY,SAAS,CAACf,SAAS,CAAC,CAAC,CAAC,CAAC;IACvBa,OAAO,CAACxL,IAAI,EAAE0L,SAAS,CAAChG,aAAa,CAAC,CAAC,EAAEgG,SAAS,CAAC/F,eAAe,CAAC,CAAC,CAAC;IACrE,OAAO3F,IAAI;EACf;EACA,SAAS+L,mBAAmBA,CAACL,SAAS,EAAE;IACpC,MAAM5E,KAAK,GAAG4E,SAAS,CAACf,SAAS,CAAC,CAAC;IACnC,MAAM7K,OAAO,GAAG4L,SAAS,CAAC5L,OAAO,CAAC,CAAC;IACnC,MAAM;MAAEoG,UAAU,EAAExJ,MAAM;MAAEyJ,YAAY,EAAEpJ;IAAI,CAAC,GAAG+C,OAAO,CAAC,CAAC;IAC3D,MAAME,IAAI,GAAGuL,SAAS,CAAC,CAAC,CAAC,gCAAgC7O,MAAM,EAAEK,GAAG,CAAC;IACrE,IAAI+J,KAAK,CAACrF,IAAI,KAAK,EAAE,CAAC,iCAAiC;MACnD;MACAgF,SAAS,CAACiF,SAAS,EAAE1O,iBAAiB,CAACY,gCAAgC,EAAEkC,OAAO,CAACqG,YAAY,EAAE,CAAC,CAAC;MACjGnG,IAAI,CAAC4B,KAAK,GAAG,EAAE;MACf4J,OAAO,CAACxL,IAAI,EAAEtD,MAAM,EAAEK,GAAG,CAAC;MAC1B,OAAO;QACHiP,gBAAgB,EAAElF,KAAK;QACvB9G;MACJ,CAAC;IACL;IACA;IACA,IAAI8G,KAAK,CAAClF,KAAK,IAAI,IAAI,EAAE;MACrB6E,SAAS,CAACiF,SAAS,EAAE1O,iBAAiB,CAACc,2BAA2B,EAAEgC,OAAO,CAACqG,YAAY,EAAE,CAAC,EAAE8F,eAAe,CAACnF,KAAK,CAAC,CAAC;IACxH;IACA9G,IAAI,CAAC4B,KAAK,GAAGkF,KAAK,CAAClF,KAAK,IAAI,EAAE;IAC9B4J,OAAO,CAACxL,IAAI,EAAE0L,SAAS,CAAChG,aAAa,CAAC,CAAC,EAAEgG,SAAS,CAAC/F,eAAe,CAAC,CAAC,CAAC;IACrE,OAAO;MACH3F;IACJ,CAAC;EACL;EACA,SAASkM,cAAcA,CAACR,SAAS,EAAE9J,KAAK,EAAE;IACtC,MAAM9B,OAAO,GAAG4L,SAAS,CAAC5L,OAAO,CAAC,CAAC;IACnC,MAAME,IAAI,GAAGuL,SAAS,CAAC,CAAC,CAAC,2BAA2BzL,OAAO,CAACpD,MAAM,EAAEoD,OAAO,CAACiG,QAAQ,CAAC;IACrF/F,IAAI,CAAC4B,KAAK,GAAGA,KAAK;IAClB4J,OAAO,CAACxL,IAAI,EAAE0L,SAAS,CAAChG,aAAa,CAAC,CAAC,EAAEgG,SAAS,CAAC/F,eAAe,CAAC,CAAC,CAAC;IACrE,OAAO3F,IAAI;EACf;EACA,SAASmM,WAAWA,CAACT,SAAS,EAAE;IAC5B,MAAM5L,OAAO,GAAG4L,SAAS,CAAC5L,OAAO,CAAC,CAAC;IACnC,MAAMsM,UAAU,GAAGb,SAAS,CAAC,CAAC,CAAC,wBAAwBzL,OAAO,CAACpD,MAAM,EAAEoD,OAAO,CAACiG,QAAQ,CAAC;IACxF,IAAIe,KAAK,GAAG4E,SAAS,CAACf,SAAS,CAAC,CAAC;IACjC,IAAI7D,KAAK,CAACrF,IAAI,KAAK,CAAC,CAAC,4BAA4B;MAC7C,MAAM4K,MAAM,GAAGN,mBAAmB,CAACL,SAAS,CAAC;MAC7CU,UAAU,CAACpL,QAAQ,GAAGqL,MAAM,CAACrM,IAAI;MACjC8G,KAAK,GAAGuF,MAAM,CAACL,gBAAgB,IAAIN,SAAS,CAACf,SAAS,CAAC,CAAC;IAC5D;IACA;IACA,IAAI7D,KAAK,CAACrF,IAAI,KAAK,CAAC,CAAC,kCAAkC;MACnDgF,SAAS,CAACiF,SAAS,EAAE1O,iBAAiB,CAACc,2BAA2B,EAAEgC,OAAO,CAACqG,YAAY,EAAE,CAAC,EAAE8F,eAAe,CAACnF,KAAK,CAAC,CAAC;IACxH;IACAA,KAAK,GAAG4E,SAAS,CAACf,SAAS,CAAC,CAAC;IAC7B;IACA,IAAI7D,KAAK,CAACrF,IAAI,KAAK,CAAC,CAAC,4BAA4B;MAC7CqF,KAAK,GAAG4E,SAAS,CAACf,SAAS,CAAC,CAAC;IACjC;IACA,QAAQ7D,KAAK,CAACrF,IAAI;MACd,KAAK,EAAE,CAAC;QACJ,IAAIqF,KAAK,CAAClF,KAAK,IAAI,IAAI,EAAE;UACrB6E,SAAS,CAACiF,SAAS,EAAE1O,iBAAiB,CAACc,2BAA2B,EAAEgC,OAAO,CAACqG,YAAY,EAAE,CAAC,EAAE8F,eAAe,CAACnF,KAAK,CAAC,CAAC;QACxH;QACAsF,UAAU,CAACxL,GAAG,GAAGsL,cAAc,CAACR,SAAS,EAAE5E,KAAK,CAAClF,KAAK,IAAI,EAAE,CAAC;QAC7D;MACJ,KAAK,CAAC,CAAC;QACH,IAAIkF,KAAK,CAAClF,KAAK,IAAI,IAAI,EAAE;UACrB6E,SAAS,CAACiF,SAAS,EAAE1O,iBAAiB,CAACc,2BAA2B,EAAEgC,OAAO,CAACqG,YAAY,EAAE,CAAC,EAAE8F,eAAe,CAACnF,KAAK,CAAC,CAAC;QACxH;QACAsF,UAAU,CAACxL,GAAG,GAAGgL,UAAU,CAACF,SAAS,EAAE5E,KAAK,CAAClF,KAAK,IAAI,EAAE,CAAC;QACzD;MACJ,KAAK,CAAC,CAAC;QACH,IAAIkF,KAAK,CAAClF,KAAK,IAAI,IAAI,EAAE;UACrB6E,SAAS,CAACiF,SAAS,EAAE1O,iBAAiB,CAACc,2BAA2B,EAAEgC,OAAO,CAACqG,YAAY,EAAE,CAAC,EAAE8F,eAAe,CAACnF,KAAK,CAAC,CAAC;QACxH;QACAsF,UAAU,CAACxL,GAAG,GAAG+K,SAAS,CAACD,SAAS,EAAE5E,KAAK,CAAClF,KAAK,IAAI,EAAE,CAAC;QACxD;MACJ,KAAK,CAAC,CAAC;QACH,IAAIkF,KAAK,CAAClF,KAAK,IAAI,IAAI,EAAE;UACrB6E,SAAS,CAACiF,SAAS,EAAE1O,iBAAiB,CAACc,2BAA2B,EAAEgC,OAAO,CAACqG,YAAY,EAAE,CAAC,EAAE8F,eAAe,CAACnF,KAAK,CAAC,CAAC;QACxH;QACAsF,UAAU,CAACxL,GAAG,GAAGiL,YAAY,CAACH,SAAS,EAAE5E,KAAK,CAAClF,KAAK,IAAI,EAAE,CAAC;QAC3D;MACJ;QAAS;UACL;UACA6E,SAAS,CAACiF,SAAS,EAAE1O,iBAAiB,CAACa,2BAA2B,EAAEiC,OAAO,CAACqG,YAAY,EAAE,CAAC,CAAC;UAC5F,MAAMmG,WAAW,GAAGZ,SAAS,CAAC5L,OAAO,CAAC,CAAC;UACvC,MAAMyM,kBAAkB,GAAGhB,SAAS,CAAC,CAAC,CAAC,2BAA2Be,WAAW,CAAC5P,MAAM,EAAE4P,WAAW,CAACvG,QAAQ,CAAC;UAC3GwG,kBAAkB,CAAC3K,KAAK,GAAG,EAAE;UAC7B4J,OAAO,CAACe,kBAAkB,EAAED,WAAW,CAAC5P,MAAM,EAAE4P,WAAW,CAACvG,QAAQ,CAAC;UACrEqG,UAAU,CAACxL,GAAG,GAAG2L,kBAAkB;UACnCf,OAAO,CAACY,UAAU,EAAEE,WAAW,CAAC5P,MAAM,EAAE4P,WAAW,CAACvG,QAAQ,CAAC;UAC7D,OAAO;YACHiG,gBAAgB,EAAElF,KAAK;YACvB9G,IAAI,EAAEoM;UACV,CAAC;QACL;IACJ;IACAZ,OAAO,CAACY,UAAU,EAAEV,SAAS,CAAChG,aAAa,CAAC,CAAC,EAAEgG,SAAS,CAAC/F,eAAe,CAAC,CAAC,CAAC;IAC3E,OAAO;MACH3F,IAAI,EAAEoM;IACV,CAAC;EACL;EACA,SAASI,YAAYA,CAACd,SAAS,EAAE;IAC7B,MAAM5L,OAAO,GAAG4L,SAAS,CAAC5L,OAAO,CAAC,CAAC;IACnC,MAAM2M,WAAW,GAAG3M,OAAO,CAACgG,WAAW,KAAK,CAAC,CAAC,wBACxC4F,SAAS,CAAChG,aAAa,CAAC,CAAC,GACzB5F,OAAO,CAACpD,MAAM;IACpB,MAAMqJ,QAAQ,GAAGjG,OAAO,CAACgG,WAAW,KAAK,CAAC,CAAC,wBACrChG,OAAO,CAACkG,MAAM,GACdlG,OAAO,CAACiG,QAAQ;IACtB,MAAM/F,IAAI,GAAGuL,SAAS,CAAC,CAAC,CAAC,yBAAyBkB,WAAW,EAAE1G,QAAQ,CAAC;IACxE/F,IAAI,CAACmB,KAAK,GAAG,EAAE;IACf,IAAIwJ,SAAS,GAAG,IAAI;IACpB,GAAG;MACC,MAAM7D,KAAK,GAAG6D,SAAS,IAAIe,SAAS,CAACf,SAAS,CAAC,CAAC;MAChDA,SAAS,GAAG,IAAI;MAChB,QAAQ7D,KAAK,CAACrF,IAAI;QACd,KAAK,CAAC,CAAC;UACH,IAAIqF,KAAK,CAAClF,KAAK,IAAI,IAAI,EAAE;YACrB6E,SAAS,CAACiF,SAAS,EAAE1O,iBAAiB,CAACc,2BAA2B,EAAEgC,OAAO,CAACqG,YAAY,EAAE,CAAC,EAAE8F,eAAe,CAACnF,KAAK,CAAC,CAAC;UACxH;UACA9G,IAAI,CAACmB,KAAK,CAACpB,IAAI,CAAC0L,SAAS,CAACC,SAAS,EAAE5E,KAAK,CAAClF,KAAK,IAAI,EAAE,CAAC,CAAC;UACxD;QACJ,KAAK,CAAC,CAAC;UACH,IAAIkF,KAAK,CAAClF,KAAK,IAAI,IAAI,EAAE;YACrB6E,SAAS,CAACiF,SAAS,EAAE1O,iBAAiB,CAACc,2BAA2B,EAAEgC,OAAO,CAACqG,YAAY,EAAE,CAAC,EAAE8F,eAAe,CAACnF,KAAK,CAAC,CAAC;UACxH;UACA9G,IAAI,CAACmB,KAAK,CAACpB,IAAI,CAAC4L,SAAS,CAACD,SAAS,EAAE5E,KAAK,CAAClF,KAAK,IAAI,EAAE,CAAC,CAAC;UACxD;QACJ,KAAK,CAAC,CAAC;UACH,IAAIkF,KAAK,CAAClF,KAAK,IAAI,IAAI,EAAE;YACrB6E,SAAS,CAACiF,SAAS,EAAE1O,iBAAiB,CAACc,2BAA2B,EAAEgC,OAAO,CAACqG,YAAY,EAAE,CAAC,EAAE8F,eAAe,CAACnF,KAAK,CAAC,CAAC;UACxH;UACA9G,IAAI,CAACmB,KAAK,CAACpB,IAAI,CAAC6L,UAAU,CAACF,SAAS,EAAE5E,KAAK,CAAClF,KAAK,IAAI,EAAE,CAAC,CAAC;UACzD;QACJ,KAAK,CAAC,CAAC;UACH,IAAIkF,KAAK,CAAClF,KAAK,IAAI,IAAI,EAAE;YACrB6E,SAAS,CAACiF,SAAS,EAAE1O,iBAAiB,CAACc,2BAA2B,EAAEgC,OAAO,CAACqG,YAAY,EAAE,CAAC,EAAE8F,eAAe,CAACnF,KAAK,CAAC,CAAC;UACxH;UACA9G,IAAI,CAACmB,KAAK,CAACpB,IAAI,CAAC8L,YAAY,CAACH,SAAS,EAAE5E,KAAK,CAAClF,KAAK,IAAI,EAAE,CAAC,CAAC;UAC3D;QACJ,KAAK,CAAC,CAAC;UAA8B;YACjC,MAAMyK,MAAM,GAAGF,WAAW,CAACT,SAAS,CAAC;YACrC1L,IAAI,CAACmB,KAAK,CAACpB,IAAI,CAACsM,MAAM,CAACrM,IAAI,CAAC;YAC5B2K,SAAS,GAAG0B,MAAM,CAACL,gBAAgB,IAAI,IAAI;YAC3C;UACJ;MACJ;IACJ,CAAC,QAAQlM,OAAO,CAACgG,WAAW,KAAK,EAAE,CAAC,wBAChChG,OAAO,CAACgG,WAAW,KAAK,CAAC,CAAC;IAC9B;IACA,MAAM4G,SAAS,GAAG5M,OAAO,CAACgG,WAAW,KAAK,CAAC,CAAC,wBACtChG,OAAO,CAACoG,UAAU,GAClBwF,SAAS,CAAChG,aAAa,CAAC,CAAC;IAC/B,MAAMM,MAAM,GAAGlG,OAAO,CAACgG,WAAW,KAAK,CAAC,CAAC,wBACnChG,OAAO,CAACsG,UAAU,GAClBsF,SAAS,CAAC/F,eAAe,CAAC,CAAC;IACjC6F,OAAO,CAACxL,IAAI,EAAE0M,SAAS,EAAE1G,MAAM,CAAC;IAChC,OAAOhG,IAAI;EACf;EACA,SAAS2M,WAAWA,CAACjB,SAAS,EAAEhP,MAAM,EAAEK,GAAG,EAAE6P,OAAO,EAAE;IAClD,MAAM9M,OAAO,GAAG4L,SAAS,CAAC5L,OAAO,CAAC,CAAC;IACnC,IAAI+M,eAAe,GAAGD,OAAO,CAACzL,KAAK,CAACD,MAAM,KAAK,CAAC;IAChD,MAAMlB,IAAI,GAAGuL,SAAS,CAAC,CAAC,CAAC,wBAAwB7O,MAAM,EAAEK,GAAG,CAAC;IAC7DiD,IAAI,CAACsB,KAAK,GAAG,EAAE;IACftB,IAAI,CAACsB,KAAK,CAACvB,IAAI,CAAC6M,OAAO,CAAC;IACxB,GAAG;MACC,MAAMnO,GAAG,GAAG+N,YAAY,CAACd,SAAS,CAAC;MACnC,IAAI,CAACmB,eAAe,EAAE;QAClBA,eAAe,GAAGpO,GAAG,CAAC0C,KAAK,CAACD,MAAM,KAAK,CAAC;MAC5C;MACAlB,IAAI,CAACsB,KAAK,CAACvB,IAAI,CAACtB,GAAG,CAAC;IACxB,CAAC,QAAQqB,OAAO,CAACgG,WAAW,KAAK,EAAE,CAAC;IACpC,IAAI+G,eAAe,EAAE;MACjBpG,SAAS,CAACiF,SAAS,EAAE1O,iBAAiB,CAACW,4BAA4B,EAAEZ,GAAG,EAAE,CAAC,CAAC;IAChF;IACAyO,OAAO,CAACxL,IAAI,EAAE0L,SAAS,CAAChG,aAAa,CAAC,CAAC,EAAEgG,SAAS,CAAC/F,eAAe,CAAC,CAAC,CAAC;IACrE,OAAO3F,IAAI;EACf;EACA,SAAS8M,aAAaA,CAACpB,SAAS,EAAE;IAC9B,MAAM5L,OAAO,GAAG4L,SAAS,CAAC5L,OAAO,CAAC,CAAC;IACnC,MAAM;MAAEpD,MAAM;MAAEqJ;IAAS,CAAC,GAAGjG,OAAO;IACpC,MAAM8M,OAAO,GAAGJ,YAAY,CAACd,SAAS,CAAC;IACvC,IAAI5L,OAAO,CAACgG,WAAW,KAAK,EAAE,CAAC,sBAAsB;MACjD,OAAO8G,OAAO;IAClB,CAAC,MACI;MACD,OAAOD,WAAW,CAACjB,SAAS,EAAEhP,MAAM,EAAEqJ,QAAQ,EAAE6G,OAAO,CAAC;IAC5D;EACJ;EACA,SAASG,KAAKA,CAACjQ,MAAM,EAAE;IACnB,MAAM4O,SAAS,GAAGlG,eAAe,CAAC1I,MAAM,EAAET,MAAM,CAAC,CAAC,CAAC,EAAEgC,OAAO,CAAC,CAAC;IAC9D,MAAMyB,OAAO,GAAG4L,SAAS,CAAC5L,OAAO,CAAC,CAAC;IACnC,MAAME,IAAI,GAAGuL,SAAS,CAAC,CAAC,CAAC,0BAA0BzL,OAAO,CAACpD,MAAM,EAAEoD,OAAO,CAACiG,QAAQ,CAAC;IACpF,IAAI/G,QAAQ,IAAIgB,IAAI,CAACjD,GAAG,EAAE;MACtBiD,IAAI,CAACjD,GAAG,CAACD,MAAM,GAAGA,MAAM;IAC5B;IACAkD,IAAI,CAACwB,IAAI,GAAGsL,aAAa,CAACpB,SAAS,CAAC;IACpC,IAAIrN,OAAO,CAAC2O,UAAU,EAAE;MACpBhN,IAAI,CAACiN,QAAQ,GAAG5O,OAAO,CAAC2O,UAAU,CAAClQ,MAAM,CAAC;IAC9C;IACA;IACA,IAAIgD,OAAO,CAACgG,WAAW,KAAK,EAAE,CAAC,sBAAsB;MACjDW,SAAS,CAACiF,SAAS,EAAE1O,iBAAiB,CAACc,2BAA2B,EAAEgC,OAAO,CAACqG,YAAY,EAAE,CAAC,EAAErJ,MAAM,CAACgD,OAAO,CAACpD,MAAM,CAAC,IAAI,EAAE,CAAC;IAC9H;IACA8O,OAAO,CAACxL,IAAI,EAAE0L,SAAS,CAAChG,aAAa,CAAC,CAAC,EAAEgG,SAAS,CAAC/F,eAAe,CAAC,CAAC,CAAC;IACrE,OAAO3F,IAAI;EACf;EACA,OAAO;IAAE+M;EAAM,CAAC;AACpB;AACA,SAASd,eAAeA,CAACnF,KAAK,EAAE;EAC5B,IAAIA,KAAK,CAACrF,IAAI,KAAK,EAAE,CAAC,sBAAsB;IACxC,OAAO,KAAK;EAChB;EACA,MAAM2H,IAAI,GAAG,CAACtC,KAAK,CAAClF,KAAK,IAAI,EAAE,EAAEkK,OAAO,CAAC,SAAS,EAAE,KAAK,CAAC;EAC1D,OAAO1C,IAAI,CAAClI,MAAM,GAAG,EAAE,GAAGkI,IAAI,CAAC8D,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,GAAG,GAAG,GAAG9D,IAAI;AAC3D;AAEA,SAAS+D,iBAAiBA,CAAC/N,GAAG,EAAEf,OAAO,GAAG,CAAC,CAAC,CAAC;AAAA,EAC3C;EACE,MAAMqB,QAAQ,GAAG;IACbN,GAAG;IACH4C,OAAO,EAAE,IAAIoL,GAAG,CAAC;EACrB,CAAC;EACD,MAAMtN,OAAO,GAAGA,CAAA,KAAMJ,QAAQ;EAC9B,MAAMiB,MAAM,GAAIyI,IAAI,IAAK;IACrB1J,QAAQ,CAACsC,OAAO,CAACqL,GAAG,CAACjE,IAAI,CAAC;IAC1B,OAAOA,IAAI;EACf,CAAC;EACD,OAAO;IAAEtJ,OAAO;IAAEa;EAAO,CAAC;AAC9B;AACA,SAAS2M,aAAaA,CAACC,KAAK,EAAEC,WAAW,EAAE;EACvC,KAAK,IAAIpM,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGmM,KAAK,CAACrM,MAAM,EAAEE,CAAC,EAAE,EAAE;IACnCqM,YAAY,CAACF,KAAK,CAACnM,CAAC,CAAC,EAAEoM,WAAW,CAAC;EACvC;AACJ;AACA,SAASC,YAAYA,CAACzN,IAAI,EAAEwN,WAAW,EAAE;EACrC;EACA,QAAQxN,IAAI,CAACyB,IAAI;IACb,KAAK,CAAC,CAAC;MACH6L,aAAa,CAACtN,IAAI,CAACsB,KAAK,EAAEkM,WAAW,CAAC;MACtCA,WAAW,CAAC7M,MAAM,CAAC,QAAQ,CAAC,0BAA0B,CAAC;MACvD;IACJ,KAAK,CAAC,CAAC;MACH2M,aAAa,CAACtN,IAAI,CAACmB,KAAK,EAAEqM,WAAW,CAAC;MACtC;IACJ,KAAK,CAAC,CAAC;MAAwB;QAC3B,MAAM1K,MAAM,GAAG9C,IAAI;QACnByN,YAAY,CAAC3K,MAAM,CAAClC,GAAG,EAAE4M,WAAW,CAAC;QACrCA,WAAW,CAAC7M,MAAM,CAAC,QAAQ,CAAC,0BAA0B,CAAC;QACvD6M,WAAW,CAAC7M,MAAM,CAAC,MAAM,CAAC,wBAAwB,CAAC;QACnD;MACJ;IACA,KAAK,CAAC,CAAC;MACH6M,WAAW,CAAC7M,MAAM,CAAC,aAAa,CAAC,+BAA+B,CAAC;MACjE6M,WAAW,CAAC7M,MAAM,CAAC,MAAM,CAAC,wBAAwB,CAAC;MACnD;IACJ,KAAK,CAAC,CAAC;MACH6M,WAAW,CAAC7M,MAAM,CAAC,aAAa,CAAC,+BAA+B,CAAC;MACjE6M,WAAW,CAAC7M,MAAM,CAAC,OAAO,CAAC,yBAAyB,CAAC;MACrD;EACR;EACA;AACJ;AACA;AACA,SAAS+M,SAASA,CAACtO,GAAG,EAAEf,OAAO,GAAG,CAAC,CAAC,CAAC;AAAA,EACnC;EACE,MAAMmP,WAAW,GAAGL,iBAAiB,CAAC/N,GAAG,CAAC;EAC1CoO,WAAW,CAAC7M,MAAM,CAAC,WAAW,CAAC,6BAA6B,CAAC;EAC7D;EACAvB,GAAG,CAACoC,IAAI,IAAIiM,YAAY,CAACrO,GAAG,CAACoC,IAAI,EAAEgM,WAAW,CAAC;EAC/C;EACA,MAAM1N,OAAO,GAAG0N,WAAW,CAAC1N,OAAO,CAAC,CAAC;EACrCV,GAAG,CAAC4C,OAAO,GAAG2L,KAAK,CAACC,IAAI,CAAC9N,OAAO,CAACkC,OAAO,CAAC;AAC7C;AAEA,SAAS6L,WAAWA,CAAC/Q,MAAM,EAAEuB,OAAO,GAAG,CAAC,CAAC,EAAE;EACvC,MAAMyP,eAAe,GAAGzR,MAAM,CAAC,CAAC,CAAC,EAAEgC,OAAO,CAAC;EAC3C,MAAM0P,GAAG,GAAG,CAAC,CAACD,eAAe,CAACC,GAAG;EACjC,MAAMC,YAAY,GAAG,CAAC,CAACF,eAAe,CAAC1L,MAAM;EAC7C,MAAM6L,cAAc,GAAGH,eAAe,CAAC3K,QAAQ,IAAI,IAAI,GAAG,IAAI,GAAG2K,eAAe,CAAC3K,QAAQ;EACzF;EACA,MAAM+K,MAAM,GAAG7C,YAAY,CAACyC,eAAe,CAAC;EAC5C,MAAM1O,GAAG,GAAG8O,MAAM,CAACnB,KAAK,CAACjQ,MAAM,CAAC;EAChC;EACA;EACA,IAAI,CAACiR,GAAG,EAAE;IACN;IACAL,SAAS,CAACtO,GAAG,EAAE0O,eAAe,CAAC;IAC/B;IACA,OAAOhM,QAAQ,CAAC1C,GAAG,EAAE0O,eAAe,CAAC;EACzC,CAAC,MACI;IACD;IACAG,cAAc,IAAI9K,QAAQ,CAAC/D,GAAG,CAAC;IAC/B;IACA4O,YAAY,IAAI5L,MAAM,CAAChD,GAAG,CAAC;IAC3B;IACA,OAAO;MAAEA,GAAG;MAAEhB,IAAI,EAAE;IAAG,CAAC;EAC5B;AACJ;;AAEA;AACA,MAAM+P,WAAW,GAAG,yBAAyB;AAC7C,MAAMC,aAAa,GAAItR,MAAM,IAAKqR,WAAW,CAACE,IAAI,CAACvR,MAAM,CAAC;AAE1D,SAASmB,gCAAgC,EAAEjB,iBAAiB,EAAE4N,YAAY,EAAEtO,aAAa,EAAEuR,WAAW,EAAE1P,kBAAkB,EAAEtB,cAAc,EAAEwO,YAAY,EAAEzO,cAAc,EAAEqC,cAAc,EAAEmP,aAAa,EAAElQ,aAAa,EAAEkE,MAAM,EAAEe,QAAQ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}